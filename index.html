<!DOCTYPE html>
<haml lang="ja">
  <head>
    <meta charset="UTF-8">
    <link href="css/bootstrap-2.3.2.css" rel="stylesheet">
    <link href="css/jquery.tocify.css" rel="stylesheet">
    <link href="css/basic.css" rel="stylesheet">
    <link href="css/replace.css" rel="stylesheet">
    <link href="lib/fontawesome/font-awesome.css" rel="stylesheet">
    <script src="js/jquery-2.1.0.js"></script>
    <script src="js/jquery-ui-1.10.4.custom.js"></script>
    <script src="js/jquery.tocify.js"></script>
    <script src="js/bootstrap-2.3.2.js"></script>
    <script src="js/replace.js"></script>
    <title>ClickJapanese</title>
  </head>
  <body>
    <div id="left_frame"></div>
    <div class="tocChild" id="right_frame">
      <header id="manualTitle">
        Click Tutorial in Japanese ver.0.4.2
      </header>
      <blockquote>― 桃Click3年、柿8年 ―</blockquote>
      <hr>
      <h3 id="what-is-click">
        Clickとは
      </h3>
      <h4>
        概要
      </h4>
      <p>
        ルーターの機能を記述するためにC++で書かれたライブラリである。
      </p>
      <p>
        現MIT助教授であるEddie Kohler氏の手によるもので、Unix系OS上で動く。
      </p>
      <h4>
        目的
      </h4>
      <p>
        昔のルーターはそもそも「ルーティング」をするだけの単純なマシンだった。すなわち
      </p>
      <strong>「いま届いたデータを目的地に届けるためには、どのケーブルに送り出すのが最善か」を判定する</strong>
      <p>
        だけの機器にすぎなかった。しかし当初は想定もしなかった機能、たとえば
      </p>
      <strong>あとから届いたデータを、先に届いたデータより優先して目的地に送り出す</strong>
      <p>
        といった機能が、リアルタイム性を重視するアプリケーション(音声通話など)の登場に伴って、切実に必要になってきた。「優先する」といっても、その判断基準は目的地がいいのか、時間帯がいいのか、それともアプリケーションの種別がいいのかは実際にやってみなければ分からない。高品質を実現するためには実験の繰り返しが不可欠であり、従来のルーターではその繰り返しが難しかった。言い換えれば、
      </p>
      <strong>実験に必要なルーターの新機能を、手早く実装する</strong>
      <p>
        仕組みが求められていた。その一つがプログラムでルーター機能を作る「ソフトウェアルータ」であり、<span class="strong_decoration">Clickの目的は、この「ソフトウェアルータ」を高速に作ることである。</span>
      </p>
      <h4>
        注意
      </h4>
      <p>
        他の言語から移ってきた方などは、必要に応じて<a class="replace_me" href="#references"></a>などを参照することをお勧めする。ClickはC++で書かれているため、C++言語の知識が前提となる。特に、拡張する（Click内に無い、自分の欲しい機能を作る）には知識がかなり必要となる。
      </p>
      <p>
        またC++に既に慣れている方は、Clickのアーキテクチャの癖を知るために<a class="replace_me" href="#click-documents"></a>に挙げた各種ドキュメントを適宜参照することをお勧めする。具体的な設計アーキテクチャは<a href="http://pdos.csail.mit.edu/papers/click:tocs00/paper.pdf">Click作者の論文</a>に記載されているが、最初から全部読むのではなくSection 1と2を読んだら一度作ってみることをお勧めする。
      </p>
      <h3 id="install-click">
        インストールする
      </h3>
      <h4 id="how-to-install-click">
        手順
      </h4>
      <p>
        インストールの手順を示す。gitとmakeとGCCはインストール済みと仮定している。GCCはclangでも動くはず。
      </p>
      <pre class="console">git clone https://github.com/kohler/click.git
cd click            # change directory
./configure --disable-linuxmodule --enable-local
make                # ./userlevel以下にClickのバイナリを作る　( ./binではないので注意 )
sudo make install   # ファイルを適切な場所へ移動(install)する（※１）</pre>
      <ol>
        <p>
          ※１ <code>/usr/local/bin</code>にClickの実行ファイル、<code>/usr/local/lib</code>にlibclick.aなどの静的ライブラリ、そして<code>/usr/share/include</code>に各種ヘッダファイルがインストールされる。）
        </p>
      </ol>
      <p>
        以上でインストールは終了である。
      </p>
      <p>
        <code>--disable-linuxmodule</code>を付けなくても成功すれば構わないが、無いと失敗するディストリビューションがある。「カーネルスペースでのClickの機能を使わない」と宣言するだけのフラグなので、初期は付けておいて問題ない。必要になればまた<code>--enable-linuxmodule</code>を付けて以上の作業を行なえばよい。また当然ながらMac OS上ではこのフラグを付けないと失敗する。
      </p>
      <pre class="errorConsole">myname@MacOS ./configure
configure: error:
=========================================

Can't find /usr/src/linux, so I can't compile the linuxmodule driver!
(You may need the --with-linux=DIR option.)

=========================================</pre>
      <p>
        --enable-localというフラグは<a href="http://read.cs.ucla.edu/click/faq#creating-your-own-elements">公式FAQ</a>で指摘されているように、のちに<code>elements/local</code>以下に自作のエレメントを追加するときに必要となる。無くても上記のコマンドは成功するが、オンにしておいたほうが無難である。重要なのでもう一度言う。<strong>オンにしておいたほうが無難である。</strong>
      </p>
      <h4>
        --disable-linuxmoduleの作用
      </h4>
      <p>
        以上で<code>/usr/local/bin</code>にClickのバイナリがインストールされた。これでようやくClickによるソフトウェアルータが起動できる...と行きたいところだが、上記のように<code>--disable-linuxmodule</code>フラグを付けて<code>./configure</code>した場合、<span class="inline_console">click/elements/linuxmodule</span>以下に存在するプログラムは<code>/usr/local</code>以下にインストールされない(<span class="inline_console">click/elements/linuxmodule</span>がどこを指すか不明であれば<a class="replace_me" href="#my-abbreviation"></a>の節を参照のこと)。
      </p>
      <p>この状態で、例えば<code>click/conf/udpcount.click</code>というソフトウェアルータを動かしてみると、以下のエラーが表示される。
      </p>
      <pre class="errorConsole">$ cat conf/udpcount.click | grep ^[^/]    # コメント行ではない行だけを表示する
  AddressInfo(the_interface 1.0.0.1 0:0:c0:8a:67:ef);
  classifier  :: Classifier(12/0800 /* IP packets */,
              12/0806 20/0001 /* ARP requests */,
              - /* everything else */);
  ip_classifier :: IPClassifier(dst udp port 1234 /* relevant UDP packets */,
          - /* everything else */);
  in_device :: PollDevice(the_interface);
  out   :: Queue(200) -> ToDevice(the_interface);
  to_host   :: ToHost;
  ctr   :: Counter /* or AverageCounter */;
  in_device -> classifier
    -> CheckIPHeader(14, CHECKSUM false) // do not check checksum for speed
    -> ip_classifier
    -> ctr
    -> Discard;
  classifier[1] -> ARPResponder(the_interface) -> out;
  classifier[2] -> to_host;
  ip_classifier[1] -> to_host;
$ sudo click conf/udpcount.click
conf/udpcount.click:17: unknown element class 'PollDevice'
conf/udpcount.click:19: unknown element class 'ToHost'</pre>
      <p>
        linuxmoduleに含まれるエレメントのみがインストールされていないことが分かる。
      </p>
      <h4 id="my-abbreviation">
        断りなく使用する略記
      </h4>
      <p><code>click/elements</code>のようにclickからパスを書き始めた場合、それは<a class="replace_me" href="#how-to-install-click"></a>の節でcloneしたclickディレクトリを指す。たとえばそのclickディレクトリが<code>/home/myname</code>にあった場合、<code>/home/myname/click</code>のことを指すものとする。
      </p>
      <p>また、<code>conf/test.click</code>や<code>elements/local</code>のようにスラッシュもしくはカレントディレクトリの表記なく唐突に書き始めた場合は<code>click/conf/test.click</code>や<code>click/elements/local</code>を指すものとする。
      </p>
      <h4 id="what-is-configure">
        configureとは何なのか
      </h4>
      <p>
        configureの正体は単なるシェルスクリプトである。しかし通常のシェルスクリプトとconfigureが違うのは、configureはautotoolsの作業工程の1つとして慣習化しており、autoconfコマンドで自動生成する、という点である。何といってもclickのconfigureは14535行もあり、どう考えても既に人力では生成できない分量である。<a href="http://ja.wikipedia.org/wiki/Autotools">Wikipedia</a>には、autoconfコマンドがaclocal.m4 (Clickであれば <code>click/aclocal.m4</code> )を入力としてconfigureを出力するなど、各コマンドの入出力ファイルが図示されている。
      </p>
      <p>
        configureの役目は、ソースコードのうち、現在のマシン上では利用できない機能を取り除き、Makefileを生成することである。
      </p>
      <h4>
        VirtualBoxのネットワークについて
      </h4>
      <p>
        以下はあくまで僕の理解である。
      </p>
      <div class="span-one-third offset4">
        <table class="table table-striped table-condensed table-bordered">
          <tr>
            <th>
              種類/通信相手
            </th>
            <th>
              インターネット上のマシン
            </th>
            <th>
              ホストOS
            </th>
            <th>
              別のゲストOS
            </th>
          </tr>
          <tr>
            <th>
              NAT
            </th>
            <td>
              O
            </td>
            <td>
              O
            </td>
            <td>
              ?
            </td>
          </tr>
          <tr>
            <th>
              Host-only
            </th>
            <td>
              X
            </td>
            <td>
              O
            </td>
            <td>
              O
            </td>
          </tr>
          <tr>
            <th>
              Internal
            </th>
            <td>
              X
            </td>
            <td>
              X
            </td>
            <td>
              O
            </td>
          </tr>
        </table>
      </div>
      <p class="span-two-thirds">
        仮想マシンにOSをインストールしたあとは、以下のように、同じマシンに対して複数のネットワーク設定を作ってしまうことを推奨する。ひとつはHost-OnlyかInternalで実験用、もう一つはNATにしておいてパッケージをインストールするときなどに使う。
      </p>
      <img src="img/2VM_network_settings.png">
      <h4 id="how-to-copy-virtual-machine">
        VirtualBoxのマシンを複製する
      </h4>
      <p>
        ネットワークの実験では3台や4台のマシンが欲しくなることも多い。その際にOS、Wireshark、Clickなどを一台ずつ個別にセットするのは手間である。VirtualBoxでは、１台必要な環境を仮想ハードディスクにインストールしてしまえばその.vdiファイルを簡単に流用できる。
      </p>
      <p>単純にコピペして、VBoxManageの<code>sethduuid</code>コマンドでUUIDを変更するのでもよいが、<code>clonevdi</code>コマンドを用いれば1手間で済む(UUIDを変更する必要があったかも？未確認)。ただしHDDが使用中だと以下のエラーを出して失敗するため、Save the machine stateでもいいので、一度止めてから再実行する。
      </p>
      <pre class="errorConsole">hst@pcname ~/click $ VBoxManage clonevdi "/Users/hst/VirtualBox VMs/vm3/server.vdi" "/Users/hst/VirtualBox VMs/vm4/clonedserver.vdi"
VBoxManage: error: Failed to lock source media '/Users/hst/VirtualBox VMs/vm3/server.vdi'
VBoxManage: error: Details: code VBOX_E_INVALID_OBJECT_STATE (0x80bb0007), component Medium, interface IMedium, callee nsISupports
VBoxManage: error: Context: 'CloneTo(dstDisk, ComSafeArrayAsInParam(l_variants), NULL, progress.asOutParam())' at line 740 of file VBoxManageDisk.cpp</pre>
      <h3>
        試す
      </h3>
      <h4 id="hello-world">
        Hello World (?)を行う
      </h4>
      <p>
        <a href="http://www.read.cs.ucla.edu/click/tutorial1#preparation">公式サイトのチュートリアル</a>の簡易版である。
      </p>
      <pre class="console">click click/conf/test.click
ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369
ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369
ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369
ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369
ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369</pre>
      <p>
        となればHello World成功である。まだconf/test.clickの中身は理解せずとも問題ない。
      </p>
      <h4 id="test-device">
        既存のClickルータを動かす
      </h4>
      <pre class="console"><sudo>click conf/test-device.click</sudo></pre>
      <p>とした上で、例えばブラウザでWebページを開くなどするとeth0に届いたパケットの先頭数十バイトが表示される。eth0がないマシン上の場合は<code>test-device.click</code>ファイル内の該当部分を変更するとよい。または以下のファイルで定義されたネットワークインターフェイスカードの識別子を書き換える方法も考えられる。
      </p>
      <pre class="console">cpr@mnt ~ $ cat /etc/udev/rules.d/70-persistent-net.rules 

# PCI device 0x8086:/sys/devices/pci0000:00/0000:00:03.0 (e1000)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="08:00:27:49:f0:94", ATTR{dev_id}=="0x0", ATTR{type}=="1", KERNEL=="eth*", NAME="eth0"</pre>
      <p>
        eth0の部分を好きな識別子に書き換えたのち、再起動すれば変更が反映される。
      </p>
      <h4 id="change-string">
        .click内の設定項目を変えてみる
      </h4>
      <p><code>conf/test.click</code>を開いてみよう。
      </p>
      <pre class="console">cat -n conf/test.click      # -n オプションは行番号を付与する
1  // test.click
2  
3  // This configuration should print this line five times:
4  // ok:   40 | 45000028 00000000 401177c3 01000001 02000002 13691369
5  
6  // Run it at user level with
7  // 'click test.click'
8  
9  // Run it in the Linux kernel with
10  // 'click-install test.click'
11  // Messages are printed to the system log (run 'dmesg' to see them, or look
12  // in /var/log/messages), and to the file '/click/messages'.
13  
14  InfiniteSource(DATA \<00 00 c0 ae 67 ef  00 00 00 00 00 00  08 00
15  45 00 00 28  00 00 00 00  40 11 77 c3  01 00 00 01
16  02 00 00 02  13 69 13 69  00 14 d6 41  55 44 50 20
17  70 61 63 6b  65 74 21 0a>, LIMIT 5, STOP true)
18    -> Strip(14)
19    -> Align(4, 0)    // in case we are not on x86
20    -> CheckIPHeader(BADSRC 18.26.4.255 2.255.255.255 1.255.255.255)
21          -> Print(ok)
22    -> Discard;</pre>
      <p>
        14 - 17行目に現れている<strong>(DATA ... , LIMIT 5, STOP true)</strong>のようなコンマで区切られた設定項目を、Click独自の用語でConfiguration stringと呼ぶ。これを使うとclickのバイナリをコンパイルし直さなくてもclickのバイナリの動作自体を変更できるため、非常にお手軽なルータの動作変更手段となっている。DATA, LIMIT, STOPと、合計３つある設定項目を合わせて1つのConfiguration stringとみなす。
      </p>
      <p>
        18行目にStrip(14)と言う設定があるが、ここでは14だけで1つのConfiguration stringを構成している。
      </p>
      <p>
        17行目について、LIMIT 5をLIMIT 1にしてみよう。そして以下のコマンドでソフトウェアルータとして動かしてみる。
      </p>
      <pre class="console">click conf/test.click
ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369</pre>
      <p>
        先ほど5回表示されたパケットの先頭部分が、1回のみ表示されている。
      </p>
      <p>同様に<code>conf/test-device.click</code>をエディタで開き、Print(ok)をPrint(noProblem)とすると、先ほど出力でokと書かれていた場所にnoProblemと表示される。次にPrint(no problem)と変えてみると、
      </p>
      <pre class="errorConsole">click conf/test.click
no: unknown argument
Router could not be initialized!</pre>
      <p>
        というエラーメッセージが出てルーターが作動しない。
      </p>
      <p>
        このような試行錯誤でもClickの作法(癖)は学べるが、いささか場当たり的である。より体系的な方法としては、該当するエレメントのmanを読むという手がある。
      </p>
      <pre class="console">man Print    # printとすると、ヒットしない！ 大文字にすること</pre>
      <p>
        これで、Clickが公式に用意した説明を読むことができる。ただし実際に読んでみると、<strong>テキスト(manの説明ではLABEL)に空白文字を含めることはできない</strong>という設計は読み取れない。さらに言えば<strong>しかし ' (クォーテーション) または " (ダブルクォーテーション) で括れば書ける</strong>という設計内容も明記されていない。このような暗黙の了解事項は、何度もルーターを少し変えては動かすことで学ぶのが一番早いだろう。この手早さがClickの1つの強みである。
      </p>
      <h4 id="read-thesis">
        Click独自の用語を知る
      </h4>
      <h5>
        Configuration file
      </h5>
      <p>
        今まで登場してきた　.click　という拡張子のファイルはClick独自のファイルでありConfiguration fileと呼ばれる。 a router configuration fileやa Click-language fileなどとも表記されるが同じものを指す。以下では「コンフファイル」もしくは「コンフィグファイル」と略記する。ルーターに実現させたい処理を記述したファイルである。
      </p>
      <pre class="console">click myFile.click</pre>
      <p>
        のように標準入力からクリックのプログラムに渡して実行することで、内部に記された処理が実行される。
      </p>
      <p>
        よって「Clickでルーターを作る」と言った際、その最終段階は必ず<strong>コンフィグファイルを作り、<br>各処理ごとのConfiguration stringを(出力を見ながら)調整する</strong>作業になる。新しいルーターを作る、という想像も付かないような作業を、必要最小限の場合としてこのレベルまで抽象化したことがClickの功績である。
      </p>
      <p>コンフファイルはより具体的には、elementと呼ばれる処理のまとまり（ふつうのプログラミング書籍でいわれるモジュールに相当する）を並べて作られる。<code>FromDevice(eth0) -> Print(ok) -> ToDevice(eth0);</code>という1行のコンフファイルであれば、FromDevice(eth0)とPrint(ok)とToDevice(eth0)の３つがelementである。
      </p>
      <h5>
        element
      </h5>
      <p>
        訳さずにelementのまま理解したほうが良いだろう。
      </p>
      <img src="img/element_architecture.png">
      <p>
        input port, output port, configuration string, element classの4つで主に構成される。あるelementのoutput portから出たデータが、コンフファイル上で矢印->でつながれた次のエレメントのinput portに入っていく、という仕組みになっている。
      </p>
      <p>
        <a href="http://pdos.csail.mit.edu/papers/click:tocs00/paper.pdf">click作者の論文</a>p.4の図からはinput portは全てのelementで必要であるかのように読み取れるが、そのすぐ下の図を見るとFromDeviceエレメントにはinput portがない。
      </p>
      <img src="img/fromdevice.png">
      <p>
        同様にToDeviceにはoutput portがない。最終的にelementを自作する際は、このように設計段階でのinput portやoutput portの数、またpullやpushと言った処理の種類に合わせてコンフファイルを書いていくことになる。その設計は<a href="http://read.cs.ucla.edu/click/doxygen/class_element.html#e5b51c221451df6a3045f7e523c2e892">port_count()関数</a>に詳しい。
      </p>
      <p>
        elementは、言語上はC++の(プライベートな内部状態を持つ)クラスとしてそれぞれ実装されている。クラスとして実装することで、C++が持つ継承やオーバーライドなどの種々の文法が使えるため、効率的な開発が可能になっている。element間でのデータの受け渡しはポインタを用いることで実装されている。
      </p>
      <h5>
        pull, push, agnostic, queue
      </h5>
      <p>
        pushのoutput port (■) はpushのinput port（▲）にしか繋げない。またpullのoutput port (□)tはpullのinput port (△)にしか繋げない。まとめれば、<strong>■ → ▲と□ → △だけが許されて、■ →△と□ → ▲は許されない</strong>ということである（エラーが出て落ちる）。agnosticは->で後続するelementがpushならばpush, pullならばpullになる柔軟なelementである。
      </p>
      <p>
        なぜpushとpullのような種別が存在するのかといえば、ルーターに求められる機能を作る上で必要だからである。たとえばパケットをNICから送り出す機能を実装する上ではpull、すなわち「NICが準備できたタイミングに応じてデータを取ってくる」機能が必要となる。
      </p>
      <p>このpushとpullがC++上でどのように実現されているかは<code>click/elements/standard/nullelement.cc</code>を見ると少し掴めるかもしれない。
      </p>
      <pre class="console">void
PushNullElement::push(int, Packet *p)
{
output(0).push(p);
}

PullNullElement::PullNullElement()
{
}

Packet *
PullNullElement::pull(int)
{
return input(0).pull();
}</pre>
      <p>
        output(0)はoutput port番号(ここでは0)に応じたElement::Portクラスのインスタンスを返す。そのクラスのメンバ関数Element::Port.element()は、「コンフファイル上で、そのoutput portで繋がれている先行または後続するエレメント」の参照を返すため、結果として<strong>output(0).push(p);は、先行するまたは後続するエレメントのpush()関数</strong>を呼び出している。なおこのような実装上の詳細はそれほど知る必要がない。ただし、<strong>「種別がpushであるエレメントA」に別のエレメントBが後続した場合、Bのpush関数が呼び出される</strong>という関係は、<a class="replace_me" href="#lets-do-programming"></a>の章で自作エレメントを実装するときに備えて理解しておきたい。
      </p>
      <p>
        また、pushとpullが繋げられないならば両者を併用することはできないのか？という疑問が生じるだろうが、その場合には間にQueueエレメントを挟む。Queueエレメントはpushのinput portとpullのoutput portを持っているため、両者をつなげることができる。通常のルーターではinput portやoutput portに暗にキューが付属していることと比べると、Queueを自由な位置に付け外しできる、更にはQueue自体の中身を自分で変更できるClickは柔軟であると言える。
      </p>
      <h5>
        keywords
      </h5>
      <p>
        <a href="http://www.read.cs.ucla.edu/click/elements">公式サイト</a>にKEYWORDSという単語が登場する。上記で登場した中ではLIMIT 5のLIMITなどがそれである。
      </p>
      <p>
        論文から理解したいことは以上の4つである。論文後半ではCPUスケジューリングについて言及があるが、パフォーマンスを考慮する段階になるまで放っておいて構わない。
      </p>
      <span class="label">configuration stringの書き方について</span>
      <p>
        <a href="http://www.read.cs.ucla.edu/click/docs/language#configuration-strings">Clickの言語仕様 </a>に文字列、IPアドレスなどそれぞれの記法が紹介されている。大体C++と同じだが、空白とコメントしか続かないカンマは無視される（即ちPrint(1,)とPrint(1)は同じ扱い）などはC++では非文なので、例外的な拡張である。
      </p>
      <p>
        上のURLの説明を<a href="http://www.read.cs.ucla.edu/click/elements">エレメントの一覧</a>と併用すれば少ないミスで書けるはず。
      </p>
      <h4 id="write-ip-router" 発展="">
        既存のelementでIPルータを作る
      </h4>
      <p>
        日経ネットワーク2013年12月号で『ソフトウェア教材「Click」で学ぶルーターの動作』という20pほどの特集が組まれている。おそらく2014年3月現時点でClickの動作について日本語でまとまって解説されているのはこの特集だけだと思われる。数十個の既存elementを組み合わせるとARP処理まで含めたＩＰルータが作れると述べている。日経の雑誌なので学内回線もしくはssl-vpnで読めるらしい。
      </p>
      <p>
        また<a href="http://pdos.csail.mit.edu/papers/click:tocs00/paper.pdf">Click作者の論文</a>にはもう少し簡単な、16コのelementで作られたIPルータが載っている。既存のエレメントのみで作れるため、Configuration stringを理解する練習台としては良いのではないだろうか(未体験)。
      </p>
      <h3>
        検索コマンドを整理する
      </h3>
      <p>
        この節では、ファイルや関数定義を探すときに役立つコマンドを整理する。Clickは複雑なディレクトリ構成をしているため、これらのコマンドを知っていないとそこで作業が詰む可能性がある。
      </p>
      <h4>
        which, locateコマンド
      </h4>
      <pre class="console">which click           # clickという名前のバイナリを探し、一番最初に見つかったものを返す
locate click          # ファイル名にclickを含むファイルを一覧表示する。</pre>
      <p>| <code>which</code>では<code>/usr/local/bin/mybinary</code>を新しくインストールしたが<code>/usr/bin/mybinary</code>が先に見つかってしまい使えない、というバグが発見できる。その場合の最も楽な解決策は
      </p>
      <pre class="console">/usr/bin/click my_config.click # 絶対パスで指定することである。</pre>
      <p></p><code>locate</code>では、<a class="replace_me" href="#install-click"></a>の章に書いた「clickバイナリがインストールされたディレクトリ」などを一覧できる。絶対パスで指定する必要に迫られた場合に役立つ。
      <h4>
        find, grepコマンド
      </h4>
      <pre class="console">find . -name click*     # 任意文字列の表記が .* ではなく * であることに注意</pre>
      <p>
        カレントディレクトリ以下に存在する、ファイル名clickで始まる任意のファイルの絶対パスを全て表示する。
      </p>
      <h4>
        ctags, cscopeライブラリ
      </h4>
      <p>
        関数名から関数定義へ飛べるツール。執筆者は使用中のエディタが対応しているという理由で<a href="http://ctags.sourceforge.net/">ctags</a>を利用している。どのドキュメントにも記載がない関数や変数を使う必要に迫られた場合、この類のツールがないとほぼ詰む。
      </p>
      <h4>
        Sublime Text 3の機能
      </h4>
      <p>
        Sublime Text 3はソースコード内の検索機能に優れたテキストエディタである。
      </p>
      <h5>
        findの強化版 (ctrl + p)
      </h5>
      <img src="img/find_sublime.gif">
      <p>
        findとは違い、正規表現を書く必要がない。Macの場合はcmd + p。
      </p>
      <h5>
        grepの強化版 (ctrl + shift + f)
      </h5>
      <img src="img/grep_sublime.gif">
      <p>
        grepとは違い、ハイパーリンク機能が付いている。行番号をクリックするとファイルが別タブで開く。Macの場合は cmd + shift + f。
      </p>
      <h4 id="click-documents">
        文書を読む
      </h4>
      <h5>
        ElementsとDriver
      </h5>
      <p>
        オンラインでは<a href="http://www.read.cs.ucla.edu/click/elements">エレメントの一覧</a>と、<a href="http://www.read.cs.ucla.edu/click/docs">内部ツールの一覧</a>から読める。オフラインでの閲覧は<a class="replace_me" href="#offline-element-doc"></a>を参照のこと。ただしDriverのmanを初期に参照することは無い。あったとしても<code>man 5 Click</code>だけだまた<code>apropos Classifier</code>でmanの全文に対してClassifierという文字列の検索が行える。
      </p>
      <h5>
        API(doxygen)
      </h5>
      <p>
        オンラインでは<a href="http://read.cs.ucla.edu/click/doxygen/">API documentation</a>から読める。このドキュメントはclick/doc以下に入っているので、doxygenというプログラムで生成すればオフラインでも読める。方法は<a class="replace_me" href="#offline-doxygen-doc"></a>を参照のこと。
      </p>
      <h4>
        Linuxの実行中情報
      </h4>
      <ul>
        <li>
          ifconfig   # NICのIPアドレス、MACアドレス、ONかOFFかを確認する。
        </li>
        <li>
          netstat    # 現在ソケット通信を行っているプログラムを表示する。
        </li>
        <li>
          route      # ルーティング表を表示する。インターネットから切り離して数台で実験する時に、静的ルーティングを設定するために使う。
        </li>
        <li>
          traceroute # パケットが届くまでに通るルーターを一覧表示する。
        </li>
        <li>
          strace     # Linuxのみ。プログラム内で呼び出したシステムコールを表示する。ソースコードを読むよりも早く実行内容を理解できるケースがある。
        </li>
        <li>
          wireshark  # パケットキャプチャ。きちんとNICに届いているかなどを確認できる。
        </li>
        <li>
          tcpdump    # 同上。遠隔マシンではwiresharkより役立つ？
        </li>
      </ul>
      <h3 id="lets-do-programming">
        作ってみる
      </h3>
      <h4 id="null-element">
        何もしないNullElement
      </h4>
      <p class="no_replace_please">
        自作のelementを使う場合、言っておかないと確実に誰もがハマって数時間を費やす注意点は<strong>./configureのときに--enable-localオプションをつけておく必要がある</strong>ということである。これをしておかないと以下で<code>click/elements/local</code>以下に自作のelementを追加しても、<code>sudo make install</code>されたとき（Clickが、その自作のelementのバイナリを含めてプログラムを再インストールするとき）にコンパイルされない。
      </p>
      <p>
        このチュートリアルでは<a class="replace_me" href="#install-click"></a>の章で既にそれに言及しているため問題はないだろうが、仮にそのオプションを指定していない場合は該当章の<code>./configure</code>を実行する前の作業から、設定をやり直す必要が生じる。
      </p>
      <p><code>click/elements/local</code>以外のディレクトリでも作る方法を以下でも解説するが、まだ一部しか理解していない(EXTRA_DRIVER_OBJSのような、外部ライブラリを使う際に違いが生じるようである)。
      </p>
      <p>
        自作elementを追加したあとは、毎回
      </p>
      <pre class="console">make elemlist　     # 「sudo make install」でコンパイルされるelementの一覧(click/elements.conf)を書き換えるコマンド。
sudo make install  # elements.confに従って自作elementをコンパイルする。C++の文法ミスなどはここでエラーが出る。</pre>
      <p>の2つのコマンドを実行する(<code>elements/local</code>以下に追加した場合はelemlistする必要はない)。それ以後、click myConfig.clickなどのコンフファイルの中でその自作elementを利用可能になる。（myConfig.clickを実行している最中に落ちた場合は、コンフィグファイルのelementの配置順の誤解、もしくは例外処理の不足が生じてエラーを出していると思われる。<code>man 1 click</code>にあるようにCLICK_BACKTRACEをONにすると原因が掴めるかも？未確認）
      </p>
      <p>
        以上に書いたような「新しいelementの作り方」の概要は<a href="http://www.read.cs.ucla.edu/click/faq#creating-your-own-elements">FAQ</a>にまとまっている。
      </p>
      <p>class_name(), port_count()は必ず実装する。push(), pull(), simple_action()はそれぞれ、push, pull, agnosticなoutput portを持つelementがそれぞれ実装する（３つのうち、どれか１つだけということである）。以上を踏まえて、<code>click/elements/standard/nullelement.cc</code>を参考に作る。
      </p>
      <p>
        更に詳しい情報は、<a href="http://www.read.cs.ucla.edu/click/doxygen/class_element.html">こちら</a>にまとまっている。
      </p>
      <p>
        なお、ドキュメントには書いてないのだがC++をある程度知っている場合によく陥る注意点として、<strong>ドキュメントで指定された関数について、余分にconstをつけてはいけない</strong>というものを挙げたい。これは、例えば<strong>int Element::configure( Vector< String > & conf, ErrorHandler * errh )</strong>について、 引数confを変更しないからと<strong>int Element::configure( const Vector< String > & conf, ErrorHandler * errh )</strong>と変更してしまうと、これは全く別の関数を宣言したことになるため、必要なインターフェイスが実装されていないということでエラーが出る。エラーメッセージが直感的でないため、このタイプのミスは事前に存在を知っておいたほうがよい。
      </p>
      <h4 id="gdb-click">
        補足. clickでgdbを使う
      </h4>
      <p>
        以下のように使う。
      </p>
      <pre class="console">ls
  my.click
which click
  /usr/local/bin/click
gdb /usr/local/bin/click

  GNU gdb (GDB) 7.7.1
  ...
  Reading symbols from /usr/local/bin/click...done.
(gdb) r my.click
  Starting program: /usr/local/bin/click my.click</pre>
      <h4 id="api-element">
        内部APIを用いるelement
      </h4>
      <p>
        新しいelementをClickで実装する際はAPIの理解が必須である。Clickは一般的なC++プログラマなら普通使うであろう「C++のSTLに含まれるStringなどの標準ライブラリクラス」を使わず、独自にそれらのStringクラスに相当するものをを実装し直して使うなどしており、呼び出す関数名や返ってくる戻り値などについてClick内部のソースコードを見ながら逐一確認する必要があるからだ。
      </p>
      <p>
        API（クラスとそのメンバ関数群）は<a href="http://read.cs.ucla.edu/click/doxygen/classes.html">こちら</a>にまとまっている。実際にはPacket.hhの説明を読んだ後、右上の虫眼鏡で検索してAPIを探していく。
      </p>
      <p>
        なおこのAPIドキュメントはオフライン閲覧もできる。<a class="replace_me" href="#offline-doxygen-doc"></a>を参照のこと。
      </p>
      <p>
        ここではまず試しに、elementが受け取ったパケットの中身を表示するエレメントを作ってみよう。 coming soon
      </p>
      <h4>
        外部ライブラリを呼び出す
      </h4>
      <p>
        coming soon
      </p>
      <h4>
        elements/local/以外で自作エレメント
      </h4>
      <p><code>click/etc/samplepackage/README</code>にあるが、コマンドの実行順序が読み取れない。不完全だが、以下までは把握した。なお、<strong>事前にclick/etc/samplepackage以下のファイルを新規フォルダにコピーしておく</strong>とよい。
      </p>
      <pre class="console">pwd                # ->  ~/click/etc/samplepackage    
ls                 # ->  configure.ac   Makefile.in   README   sampleelt.cc   sampleelt.hh   test.click

autoconf           # -> configure.acに基づき、configureコマンドが作成される。
\./configure        # -> Makefile.inに基づき、Makefileファイルが作成される。
make elemlist      # -> .ccファイル内のEXPORT_ELEMENTなどから　sample-{k,m}elements.conf　と　sample-uelem.mkが作成される。
make               # -> sample.koなど大量のオブジェクトファイルが作成される。
sudo make install  # -> sample.uoなどが無事に/usr/bin/以下あたりにインストールされる。これによって初めて以下のコマンドが成功する。
click test.click   # -> test.click: 3: While initializing 'test :: SamplePackageElement':
Successfully linked with package!</pre>
      <p>しかし、このようにパッケージとして自作エレメントのインストールを行った場合、プロファイリングコマンド<code>gprof</code>の結果(デフォルトでは<code>gprof /usr/local/bin/click gmon.out</code>)に
      </p>
      <strong>パッケージ内のエレメントが現れない(gprofで計測ができない)</strong>
      <p>
        ことに注意する。より正確には、Clickバイナリのインストール即ち
      </p>
      <pre class="console">pwd # Clickフォルダのルート
./configure CXXFLAGS="-pg" LDFLAGS="-pg" --disable-linuxmodule --enable-local   # -pgフラグによって、gmon.outファイルが生成されるようになる。<make></make></pre>
      <p>の際に、このpgがどうやらパッケージ内でmakeをしたときには適用されない模様である。解決策は探せばあるだろうが、とりあえずパッケージ内のエレメントを<code>elements/local</code>以下に移してコンパイルすることで<code>gprof</code>の結果に自作エレメントの関数が現れるようになった。
      </p>
      <h4>
        独自の.oファイルを利用する
      </h4>
      <p class="no_replace_please">ここら辺まで来ると、もはやドキュメントには全く記載がないレベルのコーディングになってくる。ソースコードが読めないと無理なレベルである。<code>click/configure.in</code>内のEXTRA_DRIVER_OBJSをセットしよう。ただし、samplepackageのように別パッケージで作った場合、<code>sudo make</code>は成功しても.clickファイルの実行時にundefined symbolエラーとなる。<code>elements/local</code>以下に置いた場合に.clickの実行まで含めて成功することは確認した。
      </p>
      <h4>
        ElementClassでエレメントを作る
      </h4>
      <p>
        「フォワーディング」とは、あるNICから入ってきたパケットを別のNICから送信する動作のことだ。主としてルータが行ない、特にIPパケットの場合はIPフォワーディングと呼称される。
      </p>
      <p>Linux環境では、<code>/proc/sys/net/ipv4/ip_forward</code>の値を1にすると、自動的にIPフォワーディングの機能が有効になる(<code>sudo sh -c "echo 1 > /proc/sys/net/ipv4/ip_forward"</code>とすればよい。元に戻すには<code>sudo sh -c "echo 0 > /proc/sys/net/ipv4/ip_forward"</code>)。これにおよそ相当する動作を、Clickのエレメントで実装してみると以下のようになる。
      </p>
      <pre class="console">elementclass MacRewriter{ $src, $dst |
  input                              // assume with ethernet header
  -> Print(____________BEFORE_REWRITING____________, MAXLENGTH 100)
  -> Strip(14)                       // remove ether header
  -> EtherEncap(0x0800, $src, $dst)  // attach new ether header
  -> Print([$src]->[$dst], MAXLENGTH 100)
  -> output
}

FromDevice(eth0)
-> MacRewriter(33:33:33:33:33:33 /*src*/, 44:44:44:44:44:44 /*dst*/)
-> Queue -> ToDevice(eth1);

// backward
FromDevice(eth1)
\-> MacRewriter(22:22:22:22:22:22, 11:11:11:11:11:11)
\-> Queue -> ToDevice(eth0);</pre><img src="img/ip_forwarding.png">
      <p>上図のような状況で、Machine2上で上記のClickソフトウェアルーターをClickコマンドで起動した場合、10.0.0.1/8と11.0.0.2/8という異なるネットワーク間でのホストでデータのやりとりができる。Machine1から<code>ping</code>が通るかping 11.0.0.2/8をして試してみよう。もっともこの場合、隣り合うマシンのMACアドレスを知っていなければならず、あまり現実的ではない（？）。
      </p>
      <p>なおVirtualBoxを使っている場合はVboxManageの<code>clonevdi</code>コマンドを用いれば、複数台のVMの用意が楽になる。<a class="replace_me" href="#how-to-copy-virtual-machine"></a>を参照のこと。
      </p>
      <h4>
        エレメントにtelnet接続する
      </h4>
      <p>エレメントのマニュアル（<code>man Print</code>など）には、MAXLENGTHなどのパラメタを列挙しているDESCRIPTIONとは別に、<strong>ELEMENT HANDLERS</strong>という項目がある。この項目に記載されたデータは、Clickの実行プロセスにtelnet接続することで、実行時に読み取ることができる。
      </p>
      <pre class="console">cat orera_wa_gomibako_yukisa.click # on the first terminal
> FromDevice(en0) -> Discard();
sudo click --port 777  orera_wa_gomibako_yukisa.click

telnet localhost 777               # on the second terminal

read list    # 稼働中のエレメントを一覧表示する
200 Read handler 'list' OK
DATA 53
3
FromDevice@1
Discard@2
click_driver@@ControlSocket

read Discard@2.count  # Discardされたパケット数を確認する
200 Read handler 'Discard@2.count' OK
DATA 3
177</pre>
      <p>
        何かと役立つだろう。Clickの論文中では/proc/click以下からhandlerにアクセスできるとあるが、これはClickをカーネルモードで実行した場合に限る。ユーザーモードではこのようなtelnetによる方法しか存在しない。
      </p>
      <h4>
        ルータ自体を動的に変える
      </h4>
      <p>
        動いているClickソフトウェアルータに新規のエレメントを追加したいとする。しかしtelnetを使う方法ではelementを動的に追加することはできない。また、一度プロセスをkillして再開する方法では、Queueエレメントに蓄積されたパケットなどが失われてしまうという問題がある。この問題を解決するために、ClickにはHot swappingという機能が備わっている。coming soon
      </p>
      <h4 id="cpp-eleven-element">
        C++11の文法でエレメントを書く
      </h4>
      <p>公式サイトには記載がないが、C++11を使うには以下の手順を踏む。<code>noext</code>は -std=c++11を意味し、<code>ext</code>とすると -std=gnu++11 をフラグとして付与する。
      </p>
      <pre class="console">cd click/m4  # 次の行でマクロファイルをダウンロード
wget http://git.savannah.gnu.org/gitweb/?p=autoconf-archive.git;a=blob_plain;f=m4/ax_cxx_compile_stdcxx_11.m4
cd click
nano click/alocal.m4  #  最終行に  m4_include([m4/ax_cxx_compile_stdcxx_11.m4])  と記述
nano configure.in     # 好きな行に　　AX_CXX_COMPILE_STDCXX_11([noext])　と記述
autoconf              # 上記の.m4 マクロファイルからconfigureを生成
./configure --enable-local --disable-linuxmodule
  ...
  checking whether g++ supports C++11 features by default... no
  checking whether g++ supports C++11 features with -std=c++11... yes    #この２行が出たら成功
  ...
sudo make
sudo make install</pre>
      <p>以上で、少なくとも<code>elements/local</code>以下でC++11の文法が使えるようになる。
      </p>
      <h3>
        更に調べる(まだ未整理)
      </h3>
      <h4 id="click-architecture-map">
        Clickの使い方を整理する
      </h4>
      <p>
        　ここまでで紹介した様々な使用法を表として整理した。
      </p>
      <table class="table table-striped table-condensed table-bordered">
        <tr>
          <th>
            追加・変更するコード
          </th>
          <th>
            手早く設定を変更できるか
          </th>
          <th>
            新機能が柔軟に追加できるか
          </th>
          <th>
            管理のしやすさ
          </th>
        </tr>
        <tr>
          <td>
            Configuration String
          </td>
          <td>
            ◎。ドキュメントを読んで.clickを書き換えるだけ。C++の知識が不要
          </td>
          <td>
            ✖。ただし既存エレメントの組み合わせで従来型ルータを作るのは柔軟かつ高速にできるのはよい。
          </td>
          <td>
            ◯。ただし次第に.clickファイルが溢れてくる
          </td>
        </tr>
        <tr>
          <td>
            elements/local内の自作エレメント
          </td>
          <td class="vertical_center" rowspan="2">
            ◯。ただし最初はAPIドキュメントをかなり読む必要がある。慣れてくるとかなり早くなる。C++の知識をかなり前提としている
          </td>
          <td>
            ◎。EXTRA_DRIVER_OBJSが使えるので事実上どんな既存のLinuxプログラムとも組み合わせられる。./configure時に-pgなどを設定できるため、デバッグや性能測定も可能
          </td>
          <td>
            ✖。他のエレメントと混ざって見にくい。複数プロジェクトで使う場合は考えたくないほど。
          </td>
        </tr>
        <tr>
          <td>
            パッケージ化した自作エレメント群
          </td>
          <td>
            △。EXTRA_DRIVER_OBJSが使えなかったり、gprofに必要な-pgフラグをどのMakefileにつければ良いのかが分からない現状では、どこかでelements/localに移す必要が出てくる。
          </td>
          <td>
            ◎。プロジェクトごとに管理可能
          </td>
        </tr>
      </table>
      <h4>
        StringとStringAccumを学ぶ
      </h4>
      <p>
        StringAccumは、Click内部で文字列の連結をかんたんに行うためのクラスである。
      </p>
      <p>
        そして、StringAccumクラスを学ぶのに最適なソースコードはズバリelements/userlevel/kernelfilter.cc内のdevice_filter()である。この関数は、実はこれまでずっと使ってきたFromDevice.uエレメント(ユーザーレベルのFromDevice)エレメントのSNIFFERというオプションをfalseにした際に呼び出される。まず、<a href="http://www.read.cs.ucla.edu/click/elements/fromdevice.u#description">FromDevice.uエレメントのSNIFFERオプションの説明</a>を読んでみよう。()内は大意である。
      </p>
      <pre>SNIFFER
Boolean. Specifies whether FromDevice should run in sniffer mode. In non-sniffer mode, FromDevice installs KernelFilter filtering rules to block the kernel from handling any packets arriving on device DEVNAME. Default is true (sniffer mode).
(SNIFFER
FromDevice(eth0, SNIFFER true) もしくは FromDevice(eth0, SNIFFER false)  のように使う。デフォルトはtrue。falseにすると、.clickファイルを動かしたときに自動的にKernelFilterエレメントのメソッドが呼び出され、eth0に届いた全てのパケットをLinuxカーネルが扱うことを防ぐ。)</pre>
      <p>要するに、FromDeviceエレメントのオプションとして、KernelFilterエレメントの一部機能が転用されている。この呼び出される「KernelFilterエレメントのメソッド」が上述のKernelFilter::device_filter()である。今度は、KernelFilterエレメントの説明(<code>man KernelFilter</code>、大文字を忘れずに)を読んでみよう。
      </p>
      <pre>DESCRIPTION
The KernelFilter element installs filter rules in the kernel to stop the kernel from handling certain types of packets. Use this in combination with FromDevice.u to handle packets in user-level Click configurations. KernelFilter uses iptables(1) to install filters; if your system does not support iptables(1), KernelFilter will fail. Normally KernelFilter uses either /sbin/iptables or /usr/sbin/iptables. To override this use the IPTABLES_COMMAND keyword argument. KernelFilter uninstalls its firewall rules when Click shuts down. If Click shuts down uncleanly, for instance because of a segmentation fault or 'kill -9', then the rules will remain in place, and you'll have to remove them yourself.
( KernelFilterエレメントは単にLinuxでファイヤーウォールを設定する際に使われる iptables コマンドのラッパーである。/sbin/iptables もしくは /usr/sbin/iptables にあるiptablesを、execl()システムコールで実行しているだけである。その２箇所のどちらにもない場合はもちろんエラーとなる。
KernelFilterによる呼出でインストールされたファイヤーウォールのフィルタリングルールすなわち
"/sbin/iptables -A INPUT -i eth0 -j DROP"  (append a rule)
などは、ClickのプログラムをCtrl - Cなどで終了させた際に
"/sbin/iptables -D INPUT -i eth0 -j DROP"  (drop a rule)
が自動的に呼ばれて消去される。ただしsegmentation faultなどで落ちた場合は残り続けるので注意。
上のコマンドを見て分かるように、残ってしまうとeth0に届いたパケットは全て捨てられてしまうので、何も通信ができない。</pre>
      <p>
        この「Clickが動いている時だけ適用されるフィルタリングルール」については、例えば以下のように確認ができる。
      </p>
      <img src="img/view_iptables.png">
      <p>Clickで作ったルーターがバックグラウンド(&)で動いている間だけ<code>、DROP all -- anywhere anywhere </code>なるとても強いフィルタリングルールが適用されていることが分かる。なおこのようなシェルプログラミングに苦手意識があるならば、<a class="replace_me" href="#references"></a>に載せた本を勧める。
      </p>
      <p>
        さて、ここまで理解した上でKernelFilter::device_filter()を見てみると、内容は一目瞭然である。StringAccumのインスタンスに対して、"/sbin/iptables" か "/usr/sbin/iptables"のどちらかの文字列を<<演算子で読み込んで、その後ろに引数を読み込んで、上述のiptablesの実行コマンド文字列を用意しているだけである。この関数のソースコードからは、以下のことが学べる。
      </p>
      <ol>
        <li>
          StringAccumクラスは&lt;&lt;演算子で文字列を連結できる。
        </li>
        <li>
          StringAccum::take_string()関数で(Click独自の)Stringクラスに変換できる。
        </li>
        <li>
          String.c_str()でchar *に変換できる。すなわちexecl()などのシステムコールに渡せる形にやっとここでなる。
        </li>
      </ol>
      <h4 id="click-detail-by-author">
        作者による内部解説
      </h4>
      <p>
        <a href="http://www.read.cs.ucla.edu/click/clickunderhood">ここ</a>が恐らく一番詳しい。
      </p>
      <h4 id="offline-element-doc">
        オフラインでエレメントのdocを読む
      </h4>
      <p><code>man FromDevice</code>などとすると読める。なお、Linuxのネットワークコマンド（<code>tcpdump</code>など）がクリックのどこで使われているかを知るには、<code>apropos tcpdump</code>などとすると一覧できて便利かと思われる。
      </p>
      <h4 id="offline-doxygen-doc">
        オフラインでAPIドキュメントを読む
      </h4>
      <p Mac="" OS="" Xの場合=""></p>
      <pre class="console">brew install doxygen     # doxygenを何らかの方法でインストール
cd (Clickのrootディレクトリ)/doc
doxygen -u               # obsoleteになった設定事項を消去。必要ないかもしれない。
doxygen                  # ドキュメントをhtmlで生成
open html/index.html     # できあがったhtml/index.htmlから閲覧する</pre>
      <p>手元の環境では<code>click/doc/Doxyfile</code>内で、
      </p>
      <ul>
        <li>
          変数DOC_FONTNAME（使われるフォント）を変更
        </li>
        <li>
          変数INPUTのパスを全て１階層上に変更(ドキュメントを含むソースコードが存在するフォルダ一覧。)<br>　たとえば、include/click ならば ../include/clickにする。
        </li>
      </ul>
      <p>
        以上を行うと環境によっては Check your TeX installation! という大量のエラーが表示されるが、.htmlのドキュメントファイルについては正常に生成される。ドキュメントのpdf化については個々人で対応されたい。
      </p>
      <h4 id="click-mailing-list">
        更に突っ込んだ話題はメーリスを漁る
      </h4>
      <p>
        たとえば"global variable site:pdos.csail.mit.edu"で検索すると、<a href="http://pdos.csail.mit.edu/pipermail/click/2009-February/007659.html">２つのエレメント間でデータを共有するにはグローバル変数で良いが、果たしてそれらのエレメントが同じコンフィグファイル内で複数回使われたらどうなるのか教えて欲しい</a>という話題が出てくる。残念ながらリンク先からはその答えが見つけられないが、自分がいま探しているのが２つのエレメント間での共有だけであれば、このページを読むだけでグローバル変数を.ccファイルに書けばよいと勘付けるだろう。
      </p>
      <p>また、gprofでクリックのエレメントの速度測定が可能かなどの話題についても作者が既にメーリス内で答えている。（userlevel Clickでは可能で、Kernel Levelでは<code>oprofile</code>を用いる）
      </p>
      <h4>
        その他まだ未整理の話題
      </h4>
      <h5>
        複数element間でのデータの受け渡し
      </h5>
      <p>
        ３つの方法を思いついた。
      </p>
      <table class="table table-striped table-condensed table-bordered">
        <tr>
          <th>
            方法
          </th>
          <th>
            長所
          </th>
          <th>
            短所
          </th>
        </tr>
        <tr>
          <td>
            ColorというPacketの空きスペースを使う
          </td>
          <td>
            不明
          </td>
          <td>
            やり方が不明
          </td>
        </tr>
        <tr>
          <td><code>click/conf/mazu-net.click</code>の<code>GatewayDevice</code>で$device変数が2度参照されているのと同様の手法を使う
          </td>
          <td>
            コンフファイル中の変更が一元管理できる。<a href="http://www.read.cs.ucla.edu/click/docs/language#configuration-parameters">公式サイト</a>にも方法に言及がある。
          </td>
          <td>
            ルータ起動時にしか設定ができない。実行中のパラメタなどを渡せない。
          </td>
        </tr>
        <tr>
          <td>
            グローバル変数
          </td>
          <td>
            cc内でグローバル変数を宣言し、もう片方の.cc内でexternして受け取るだけ。非常にお手軽で高速
          </td>
          <td>
            グローバル汚染の可能性。また、同じエレメントが複数個.clickにあった場合、何が起きるかは未確認
          </td>
        </tr>
      </table>
      <h5>
        以上に出てこない関数など
      </h5>
      <p>
        click/ns/nsclick.ccで定義される引数なしのclick_random()がそれである。このような関数の定義元を探す場合、ソースコードにタグ付けするcscopeや<a href="http://ctags.sourceforge.net/">ctags</a>といったソフトを使うしかないと思われる。私はsublime text 3のctagsパッケージにずいぶん助けられている。
      </p>
      <h5>
        miscellaneous
      </h5>
      <ol>
        <li>
          click(1)にチラっと書いてあるCLICK_BACKTRACE怪しい これをONにすればエラー特定に役立つのではないか？
        </li>
        <li>
          click作者の論文の第５章を読めばカーネルモードについて理解が深まるのでは
        </li>
        <li>
          google code prettifyいいかも
        </li>
        <li>
          bootstrapなのにグリッドデザインじゃないね
        </li>
        <li>
          CheckIPHeaderを内部APIを用いるelementのところに書く
        </li>
      </ol>
      <h5>
        clickの位置付け
      </h5>
      <p>
        （誤認の可能性が高い。よってこの項目の記述内容は容易に変動する。）
      </p>
      <p>
        ClickはUnix系OSにおけるネットワーク系コマンド群をKohler氏の思想によってまとめ上げ、機能を追加し、さらに拡張可能にした巨大なプログラムである。複雑化の制御の過程で単に標準入力のコマンドのような設定項目の羅列や項目の羅列である設定ファイルではなく、DSLのような特性が生じた。(※DSL…Domain Specific Languageドメイン固有言語。特定のタスク遂行に特化した言語。コンパイル支援におけるmake、文章構造化におけるHTMLなどがその例。) Kohler氏の研究興味分野にプログラミング言語が入っていることは興味深い（networks, programming languagesと並ぶのは比較的珍しい）。その結果としてネットワークの設定が標準入力コマンドのオプション引数やいわゆる設定ファイルよりも遥かに人間の思考に沿ったかたちで記述・構築可能になった。これがClickの思想的な業績であると私は考える。この発想は東京大学・中尾彰宏教授のToy-Block Networkingなどの研究に影響を与えたと想定される。Clickは今まで述べてきたようにelements間については厳格な形式制限があるが、ソースコードのレベルにおいては様々なライブラリを柔軟に取り込むことができる。STLの標準ライブラリを取り込むことも可能であるし、たとえばnetstatの機能を内部に追加するなども(更に高度になるが)可能である。実際、ClickのKernelFilterエレメントはiptablesコマンドをそのまま呼び出している。
      </p>
      <h3 id="references">
        参考文献
      </h3>
      <ul>
        <li>
          <a href="http://www.gnu.org/software/make/manual/make.html">GNUによる公式マニュアル</a> ... makeはググって情報を探すことに向いていない。Clickを学んでいてmakeについて疑問が生じたら、このマニュアルかAndrew Oramの『make 改訂版』を参照することを推奨する。
        </li>
        <li>
          『ストラウストラップのプログラミング入門』 ... const参照の意義についての説明は感動。
        </li>
        <li>
          『詳説 Cポインタ』 ... 2章まで読むだけでも、ポインタの概要が分かる。
        </li>
        <li>
          『Linux Programming Interface』の41章 ... 静的/動的リンクについて詳細な説明がなされている。リンクのエラーはググっても解決策が出てこない（もしくはとても読みにくい）ことが多く、先に全体を知ってしまったほうが無難である。
        </li>
        <li>
          『Linuxネットワークプログラミングバイブル』 ... ソケット通信の初歩を大量のサンプルコードと共に学べる。
        </li>
        <li>
          "A practical guide to Linux commands, editors, and shell programming"(Mark G. Sobell, 2012)のChapter 2, 3, 4, 5, 8, 10』... シェルプログラミングを基礎から学べる良書。パラパラ見るだけでも発見がある。
        </li>
      </ul>
      <h4>
        その他
      </h4>
      <ul>
        <li class="no_replace_please">
          誤植や誤解などありましたら<a href="https://github.com/caprice-j/click_tutorial_in_Japanese">github</a>へお願いします
        </li>
      </ul>
      <h4>
        使用ライブラリ等
      </h4>
      <ul>
        <li>
          <a href="http://jquery.com/">jQuery 2.1.0</a>未だにソースコード読んでいない
        </li>
        <li>
          <a href="http://getbootstrap.com/2.3.2/">twitter-bootstrap 2.3.2</a>世間では3.x系も出ているらしいが2.x系のデザインの方が好きである
        </li>
        <li>
          <a href="http://gregfranko.com/jquery.tocify.js/">jquery.tocify.js 1.9.0</a>現在位置を表示してくれる目次というのは素晴らしい
        </li>
        <li>
          <a href="http://fortawesome.github.io/Font-Awesome/">Font Awesome 4.1.0</a>アイコンに色を付けたかった
        </li>
        <li>
          <a href="http://alphapixels.com/prepros/">Prepros 4.2.0</a>.slimと.scssを.htmlにコンパイルするアプリ　slimの存在を教えて下さったT先輩に感謝
        </li>
      </ul>
      <h4>
        このチュートリアルに付けたい機能
      </h4>
      <ul>
        <li>
          目次 ... 済(ライブラリ)
        </li>
        <li>
          辞書 ... 自作済　まだちょっと使いにくい 
          <ul>
            <li>
              端で切れるのを改善したい
            </li>
            <li>
              .gzの説明が切れるのを直したい
            </li>
            <li>
              複数表示したままにしたい
            </li>
            <li>
              aタグ内の文字の扱いを改良したい(現状それが原因でバグが起こるため文章を変えて回避中)
            </li>
          </ul>
        </li>
        <li>
          画像gif化 ... 済み　ただしより開発しやすいツールを探したい
        </li>
      </ul>
      <h4>
        開発履歴
      </h4>
      <p>
        2014年
      </p>
      <ul>
        <li>
          0324  何となく書き始める
        </li>
        <li>
          0325  公開したら.txtですら案外好評だったので続ける気になる
        </li>
        <li>
          0402  目次をフレーム化するためにhtml化
        </li>
        <li>
          0530  IP forwardingの項を追加
        </li>
        <li>
          0603  FAQの存在を発見、リンクに追加
        </li>
        <li>
          0604  Haml, Scssで全て書き直した
        </li>
        <li>
          0605  指摘を受けて修正　誤：element/nullelement.cc 　正： element/standard/nullelement.cc
        </li>
        <li>
          0629  hamlをslimで書き直した
        </li>
        <li>
          0712  jquery.tocify.jsを利用して動的な目次を作成
        </li>
        <li>
          0713  辞書機能を追加、4章までの説明を大きく追加
        </li>
        <li>
          0714  Click作者の論文を2章まで読み直し、記述を大幅に追加
        </li>
      </ul>
      <script type="text/javascript">
        $(function() {
            //Calls the tocify method on your HTML div.
            $("#left_frame").tocify({showEffect: "none", hideEffect: "none"});
        });
      </script>
    </div>
  </body>
</haml>
