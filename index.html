<!DOCTYPE html>
<haml lang="ja">
  <head>
    <meta charset="UTF-8">
    <link href="css/bootstrap-2.3.2.css" rel="stylesheet">
    <link href="css/jquery.tocify.css" rel="stylesheet">
    <link href="css/basic.css" rel="stylesheet">
    <link href="css/replace.css" rel="stylesheet">
    <link href="lib/fontawesome/font-awesome.css" rel="stylesheet">
    <script src="js/jquery-2.1.0.js"></script>
    <script src="js/jquery-ui-1.10.4.custom.js"></script>
    <script src="js/jquery.tocify.js"></script>
    <script src="js/bootstrap-2.3.2.js"></script>
    <script src="js/replace.js"></script>
    <title>ClickJapanese</title>
  </head>
  <body>
    <div id="left_frame"></div>
    <div class="tocChild" id="right_frame">
      <header id="manualTitle">
        Click Tutorial in Japanese ver.0.4.2
      </header>
      <strong>― 桃Click3年、柿8年 ―</strong>
      <hr>
      <h3 id="what-is-click">
        Clickとは
      </h3>
      <h4>
        概要
      </h4>
      <p>
        ルーターの機能を記述するためにC++で書かれたライブラリである。
      </p>
      <p>
        現MIT助教授であるEddie Kohler氏の手によるもので、Unix系OS上で動く。
      </p>
      <h4>
        目的
      </h4>
      <p>
        昔のルーターはそもそも「ルーティング」をするだけの単純なマシンだった。すなわち
      </p>
      <strong>「いま届いたデータを目的地に届けるためには、どのケーブルに送り出すのが最善か」を判定する</strong>
      <p>
        だけの機器にすぎなかった。しかし当初は想定もしなかった機能、たとえば
      </p>
      <strong>あとから届いたデータを、先に届いたデータより優先して目的地に送り出す</strong>
      <p>
        といった機能が、リアルタイム性を重視するアプリケーション(音声通話など)の登場に伴って、切実に必要になってきた。「優先する」といっても、その判断基準は目的地がいいのか、時間帯がいいのか、それともアプリケーションの種別がいいのかは実際にやってみなければ分からない。高品質を実現するためには実験の繰り返しが不可欠であり、従来のルーターではその繰り返しが難しかった。言い換えれば、
      </p>
      <strong>実験に必要なルーターの新機能を、手早く実装する</strong>
      <p>
        仕組みが求められていた。その一つがプログラムでルーター機能を作る「ソフトウェアルータ」であり、<span class="strong_decoration">Clickの目的は、この「ソフトウェアルータ」を高速に作ることである。</span>
      </p>
      <h4>
        注意
      </h4>
      <p>
        他の言語から移ってきた方などは、必要に応じて<a class="replace_me" href="#references"></a>などを参照することをお勧めする。ClickはC++で書かれているため、C++言語の知識が前提となる。特に、拡張する（Click内に無い、自分の欲しい機能を作る）には知識がかなり必要となる。
      </p>
      <p>
        またC++に既に慣れている方は、Clickのアーキテクチャの癖を知るために<a class="replace_me" href="#click-documents"></a>に挙げた各種ドキュメントを適宜参照することをお勧めする。具体的な設計アーキテクチャは<a href="http://pdos.csail.mit.edu/papers/click:tocs00/paper.pdf">Click作者の論文</a>に記載されている。
      </p>
      <h3 id="install-click">
        インストールする
      </h3>
      <h4 id="how-to-install-click">
        手順
      </h4>
      <p>
        インストールの手順を示す。gitとmakeとGCCはインストール済みと仮定している。GCCはclangでも動くはず。
      </p>
      <pre class="console">git clone https://github.com/kohler/click.git
cd click            # change directory
./configure --disable-linuxmodule --enable-local
make                # ./userlevel以下にClickのバイナリを作る　( ./binではないので注意 )
sudo make install   # ファイルを適切な場所へ移動(install)する（※１）</pre>
      <ol>
        <p>
          （※１ /usr/local/binにClickの実行ファイル、/usr/local/libにlibclick.aなどの静的ライブラリ、/usr/share/includeにヘッダファイルがインストールされる。）
        </p>
      </ol>
      <p>
        以上でインストールは終了である。
      </p>
      <p>
        --disable-linuxmoduleを付けなくても成功すれば構わないが、無いと失敗するディストリビューションがある。「カーネルスペースでのClickの機能を使わない」と宣言するだけのフラグなので、初期は付けておいて問題ない。必要になればまた--enable-linuxmoduleを付けて以上の作業を行なえばよい。また当然ながらMac OS上ではこのフラグを付けないと失敗する。エラーメッセージは以下である。
      </p>
      <pre class="errorConsole">configure: error:
=========================================

Can't find /usr/src/linux, so I can't compile the linuxmodule driver!
(You may need the --with-linux=DIR option.)

=========================================</pre>
      <p>
        --enable-localというフラグは<a href="http://read.cs.ucla.edu/click/faq#creating-your-own-elements">公式FAQ</a>で指摘されているように、のちにelements/local フォルダ以下に自作のエレメントを追加するときに必要となる。無くても上記のコマンドは成功するが、オンにしておいたほうが無難である。重要なのでもう一度言う。<strong>オンにしておいたほうが無難である。</strong>
      </p>
      <h4>
        --disable-linuxmoduleの作用
      </h4>
      <p>
        以上で/usr/local/binにClickのバイナリがインストールされた。これでようやくClickによるソフトウェアルータが起動できる...と行きたいところだが、上記のように--disable-linuxmoduleフラグを付けて./configureした場合、click/elements/linuxmodule以下に存在するプログラムは/usr/local/以下にインストールされない(click/elements/linuxmoduleがどこを指すか不明であれば<a class="replace_me" href="#my-abbreviation"></a>の節を参照のこと)。
      </p>
      <p>
        この状態で、例えばclick/conf/udpcount.clickというルーター設定で動かしてみると、以下のエラーが表示される。
      </p>
      <pre class="errorConsole">$sudo click conf/udpcount.click
conf/udpcount.click:17: unknown element class 'PollDevice'
conf/udpcount.click:19: unknown element class 'ToHost'</pre>
      <p>
        linuxmoduleに含まれるエレメントがインストールされていないことが分かる。
      </p>
      <h4 id="my-abbreviation">
        断りなく使用する略記
      </h4>
      <p>
        click/elements/のようにclickからパスを書き始めた場合、それは<a class="replace_me" href="#how-to-install-click"></a>の節でcloneしたclickディレクトリを指す。たとえばそのclickディレクトリが/home/myname/にあった場合、/home/myname/clickのことを指すものとする。
      </p>
      <p>
        また、conf/test.clickのように唐突に書き始めた場合はclick/conf/test.clickを指すものとする。
      </p>
      <h4>
        VirtualBoxのネットワークについて
      </h4>
      <p>
        以下はあくまで僕の理解である。
      </p>
      <table class="table table-striped table-condensed table-bordered">
        <tr>
          <th>
            種類/通信相手
          </th>
          <th>
            インターネット上のマシン
          </th>
          <th>
            ホストOS
          </th>
          <th>
            別のゲストOS
          </th>
        </tr>
        <tr>
          <th>
            NAT
          </th>
          <td>
            O
          </td>
          <td>
            O
          </td>
          <td>
            ?
          </td>
        </tr>
        <tr>
          <th>
            Host-only
          </th>
          <td>
            X
          </td>
          <td>
            O
          </td>
          <td>
            O
          </td>
        </tr>
        <tr>
          <th>
            Internal
          </th>
          <td>
            X
          </td>
          <td>
            X
          </td>
          <td>
            O
          </td>
        </tr>
      </table>
      <p>
        仮想マシンにOSをインストールしたあとは、以下のように、同じマシンに対して複数のネットワーク設定を作ってしまうことを推奨する。ひとつはHost-OnlyかInternalで実験用、もう一つはNATにしておいてパッケージをインストールするときなどに使う。
      </p>
      <img src="img/2VM_network_settings.png">
      <h4 id="how-to-copy-virtual-machine">
        VirtualBoxのマシンを複製する
      </h4>
      <p>
        ネットワークの実験では3台や4台のマシンが欲しくなることも多い。その際にOS、Wireshark、Clickなどを一台ずつ個別にセットするのは手間である。VirtualBoxでは、１台必要な環境を仮想ハードディスクにインストールしてしまえばその.vdiファイルを簡単に流用できる。
      </p>
      <p>
        単純にコピペして、VBoxManageのsethduuidコマンドでUUIDを変更するのでもよいが、clonevdiコマンドを用いれば1手間で済む(UUIDを変更する必要があったかも？未確認)。ただしHDDが使用中だと以下のエラーを出して失敗するため、Save the machine stateでもいいので、一度止めてから再実行する。
      </p>
      <pre class="errorConsole">hst@pcname ~/click $ VBoxManage clonevdi "/Users/hst/VirtualBox VMs/vm3/server.vdi" "/Users/hst/VirtualBox VMs/vm4/clonedserver.vdi"
VBoxManage: error: Failed to lock source media '/Users/hst/VirtualBox VMs/vm3/server.vdi'
VBoxManage: error: Details: code VBOX_E_INVALID_OBJECT_STATE (0x80bb0007), component Medium, interface IMedium, callee nsISupports
VBoxManage: error: Context: 'CloneTo(dstDisk, ComSafeArrayAsInParam(l_variants), NULL, progress.asOutParam())' at line 740 of file VBoxManageDisk.cpp</pre>
      <h3>
        試す
      </h3>
      <h4 id="hello-world">
        Hello World (?)を行う
      </h4>
      <p>
        <a href="http://www.read.cs.ucla.edu/click/tutorial1#preparation">公式サイトのチュートリアル</a>の簡易版である。
      </p>
      <pre class="console">click click/conf/test.click
ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369
ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369
ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369
ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369
ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369</pre>
      <p>
        となればHello World成功である。まだconf/test.clickの中身は理解せずとも問題ない。
      </p>
      <h4 id="test-device">
        既存のClickルータを動かす
      </h4>
      <pre class="console"><sudo>click conf/test-device.click</sudo></pre>
      <p>
        とした上で、例えばブラウザでWebページを開くなどするとeth0に届いたパケットの先頭数十バイトが表示される。eth0がないマシン上の場合はtest-device.clickファイル内の該当部分を変更するとよい。または以下のファイルで定義されたネットワークインターフェイスカードの識別子を書き換える方法も考えられる。
      </p>
      <pre class="console">cpr@mnt ~ $ cat /etc/udev/rules.d/70-persistent-net.rules 

# PCI device 0x8086:/sys/devices/pci0000:00/0000:00:03.0 (e1000)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="08:00:27:49:f0:94", ATTR{dev_id}=="0x0", ATTR{type}=="1", KERNEL=="eth*", NAME="eth0"</pre>
      <p>
        eth0の部分を好きな識別子に書き換えたのち、再起動すれば変更が反映される。
      </p>
      <h4 id="change-string">
        .click内の設定項目を変えてみる
      </h4>
      <p>
        conf/test.clickを開いてみよう。
      </p>
      <pre class="console">cat -n conf/test.click      # -n オプションは行番号を付与する
1  // test.click
2  
3  // This configuration should print this line five times:
4  // ok:   40 | 45000028 00000000 401177c3 01000001 02000002 13691369
5  
6  // Run it at user level with
7  // 'click test.click'
8  
9  // Run it in the Linux kernel with
10  // 'click-install test.click'
11  // Messages are printed to the system log (run 'dmesg' to see them, or look
12  // in /var/log/messages), and to the file '/click/messages'.
13  
14  InfiniteSource(DATA \<00 00 c0 ae 67 ef  00 00 00 00 00 00  08 00
15  45 00 00 28  00 00 00 00  40 11 77 c3  01 00 00 01
16  02 00 00 02  13 69 13 69  00 14 d6 41  55 44 50 20
17  70 61 63 6b  65 74 21 0a>, LIMIT 5, STOP true)
18    -> Strip(14)
19    -> Align(4, 0)    // in case we are not on x86
20    -> CheckIPHeader(BADSRC 18.26.4.255 2.255.255.255 1.255.255.255)
21          -> Print(ok)
22    -> Discard;</pre>
      <p>
        14 - 17行目に現れている<strong>(DATA ... , LIMIT 5, STOP true)</strong>のようなコンマで区切られた設定項目を、Click独自の用語でConfiguration stringと呼ぶ。DATA, LIMIT, STOPと、合計３つある設定項目を合わせて1つのConfiguration stringとみなす。
      </p>
      <p>
        18行目にStrip(14)と言う設定があるが、ここでは14だけで1つのConfiguration stringを構成している。
      </p>
      <p>
        17行目について、LIMIT 5をLIMIT 1にしてみよう。そして以下のコマンドでソフトウェアルータとして動かしてみる。
      </p>
      <pre class="console">click conf/test.click
ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369</pre>
      <p>
        先ほど5回表示されたパケットの先頭部分が、1回のみ表示されている。
      </p>
      <p>
        同様にconf/test-device.clickをエディタで開き、Print(ok)をPrint(noProblem)とすると、先ほど出力でokと書かれていた場所にnoProblemと表示される。次にPrint(no problem)と変えてみると、
      </p>
      <pre class="errorConsole">click conf/test.click
no: unknown argument
Router could not be initialized!</pre>
      <p>
        というエラーメッセージが出てルーターが作動しない。
      </p>
      <p>
        このような試行錯誤でもClickの作法(癖)は学べるが、いささか場当たり的である。より体系的な方法としては、該当するエレメントのmanを読むという手がある。
      </p>
      <pre class="console">man Print    # printとすると、ヒットしない！ 大文字にすること</pre>
      <p>
        これで、Clickが公式に用意した説明を読むことができる。ただし実際に読んでみると、<strong>テキスト(manの説明ではLABEL)に空白文字を含めることはできない</strong>という設計は読み取れない。さらに言えば<strong>しかし ' (クォーテーション) または " (ダブルクォーテーション) で括れば書ける</strong>という設計内容も明記されていない。このような暗黙の了解事項は、何度もルーターを少し変えては動かすことで学ぶのが一番早いだろう。この手早さがClickの1つの強みである。
      </p>
      <h4 id="read-thesis">
        Click独自の用語を知る
      </h4>
      <h5>
        Configuration file
      </h5>
      <p>
        今まで登場してきた　.click　という拡張子のファイルはClick独自のファイルでありConfiguration fileと呼ばれる。以下では「コンフファイル」もしくは「コンフィグファイル」と略記する。ルーターに実現させたい処理を記述したファイルである。
      </p>
      <pre class="console">click myFile.click</pre>
      <p>
        のように標準入力からクリックのプログラムに渡して実行することで、内部に記された処理が実行される。
      </p>
      <p>
        よって「Clickでルーターを作る」と言った際、その最終段階は必ず<strong>コンフィグファイルを作り、<br>各処理ごとのConfiguration stringを(出力を見ながら)調整する</strong>作業になる。ルーターを作る、という想像も付かないような作業を、必要最小限の場合としてこのレベルまで抽象化したことがClickの功績である。
      </p>
      <p>
        コンフファイルはより具体的には、elementと呼ばれる処理のまとまり（ふつうのプログラミング書籍でいわれるモジュールに相当する？）を並べて作られる。FromDevice(eth0) -> Print(ok) -> ToDevice(eth0);という1行のコンフファイルであれば、FromDevice(eth0)とPrint(ok)とToDevice(eth0)の３つがelementである。
      </p>
      <h5>
        element
      </h5>
      <p>
        訳さずにelementのまま理解したほうが良いだろう。
      </p>
      <img src="img/element_architecture.png">
      <p>
        input port, output port, configuration string, element classの4つで主に構成される。図解や制限は<a href="http://pdos.csail.mit.edu/papers/click:tocs00/paper.pdf">click作者の論文</a>のp.4にあるelementの図に任せる。
      </p>
      <p>
        p.4の図からはinput portは全てのelementに必要に思えるが、そのすぐ下の図を見るとFromDeviceなどはinput portがない。
      </p>
      <img src="img/fromdevice.png">
      <p>
        同様にToDeviceにはoutput portがない。最終的にelementを自作する際は、このように設計段階でのinput portやoutput portの数、またpullやpushと言った処理の種類に合わせてコードを書いていくことになる。その設計は<a href="http://read.cs.ucla.edu/click/doxygen/class_element.html#e5b51c221451df6a3045f7e523c2e892">port_count()関数</a>に詳しい。
      </p>
      <h5>
        pull, push, agnostic
      </h5>
      <p>
        上記論文p.4のelementの図において、黒く塗りつぶされている三角・四角がpushのinput portとoutput portであり、そうでない三角・四角がpullのinput portとoutput portである。pushのinput portはpushのoutput portにしか繋げない。またpullのinput portはpullのoutput portにしか繋げない。絵で言えば、<strong>■ → ▲と□ → △だけが許されて、■ →△と□ → ▲は許されない</strong>ということである（エラーが出て落ちる）。agnosticは後続するelementがpushならばpush, pullならばpullになる柔軟なelementである。
      </p>
      <p>
        このpushとpullがC++上でどのように実現されているかはclick/elements/standard/nullelement.ccを見ると掴めるかもしれない?
      </p>
      <pre class="console">void
PushNullElement::push(int, Packet *p)
{
output(0).push(p);
}

PullNullElement::PullNullElement()
{
}

Packet *
PullNullElement::pull(int)
{
return input(0).pull();
}</pre>
      <h5>
        keywords
      </h5>
      <p>
        <a href="http://www.read.cs.ucla.edu/click/elements">公式サイト</a>にKEYWORDSという単語が登場する。上記で登場した中ではLIMIT 5のLIMITなどがそれである。
      </p>
      <p>
        論文から理解したいことは以上の4つである。論文後半ではCPUスケジューリングについて言及があるが、パフォーマンスを考慮する段階になるまで放っておいて構わない。
      </p>
      <h6>
        注. configuration stringの書き方、文法
      </h6>
      <p>
        <a href="http://www.read.cs.ucla.edu/click/docs/language#configuration-strings">Clickの言語仕様 </a>に文字列、IPアドレスなどそれぞれの記法が紹介されている。大体C++と同じだが、空白とコメントしか続かないカンマは無視される（即ちPrint(1,)とPrint(1)は同じ扱い）などはC++では非文なので、例外的な拡張である。
      </p>
      <p>
        上のURLの説明を<a href="http://www.read.cs.ucla.edu/click/elements">エレメントの一覧</a>と併用すれば少ないミスで書けるはず。
      </p>
      <h4 id="write-ip-router" 発展="">
        既存のelementでIPルータを作る
      </h4>
      <p>
        日経ネットワーク2013年12月号で『ソフトウェア教材「Click」で学ぶルーターの動作』という20pほどの特集が組まれている。おそらく2014年3月現時点でClickの動作について日本語でまとまって解説されているのはこの特集だけだと思われる。数十個の既存elementを組み合わせるとARP処理まで含めたＩＰルータが作れると述べている。日経の雑誌なので学内回線もしくはssl-vpnで読めるらしい。
      </p>
      <h3>
        検索コマンドを整理する
      </h3>
      <p>
        この節では、ファイルや関数定義を探すときに役立つコマンドを整理する。Clickは複雑なディレクトリ構成をしているため、これらのコマンドを知っていないとそこで作業が詰む可能性がある。
      </p>
      <h4>
        which, locateコマンド
      </h4>
      <pre class="console">which click           # clickという名前のバイナリを探し、一番最初に見つかったものを返す
locate click          # ファイル名にclickを含むファイルを一覧表示する。</pre>
      <p>
        | whichでは/usr/binに新しくインストールしたが/usr/local/binが先に見つかってしまい使えない、というバグが発見できる。その場合の最も楽な解決策は
      </p>
      <pre class="console">/usr/bin/click my_config.click # 絶対パスで指定することである。</pre>
      <p></p>
      locateでは、<a class="replace_me" href="#install-click"></a>の章に書いた「clickバイナリがインストールされたディレクトリ」などを一覧できる。絶対パスで指定する必要に迫られた場合に役立つ。
      <h4>
        find, grepコマンド
      </h4>
      <pre class="console">find . -name click*     # 任意文字列の表記が .* ではなく * であることに注意</pre>
      <p>
        カレントディレクトリ以下に存在する、ファイル名clickで始まる任意のファイルの絶対パスを全て表示する。
      </p>
      <h4>
        ctags, cscopeライブラリ
      </h4>
      <p>
        関数名から関数定義へ飛べるツール。筆者は使用中のエディタで使える<a href="http://ctags.sourceforge.net/">ctags</a>を利用している。
      </p>
      <h4>
        Sublime Text 3の機能
      </h4>
      <p>
        Sublime Text 3はソースコード内の検索機能に優れたテキストエディタである。
      </p>
      <h5>
        findの強化版 (ctrl + p)
      </h5>
      <img src="img/find_sublime.png">
      <p>
        findとは違い、正規表現を書く必要がない。
      </p>
      <h5>
        grepの強化版 (ctrl + shift + f)
      </h5>
      <img src="img/grep_sublime.png">
      <p>
        grepとは違い、ハイパーリンク機能が付いている。行番号をクリックするとファイルが別タブで開く。
      </p>
      <h4 id="click-documents">
        文書を読む
      </h4>
      <h5>
        ElementsとDriver
      </h5>
      <p>
        オンラインでは<a href="http://www.read.cs.ucla.edu/click/elements">エレメントの一覧</a>と、<a href="http://www.read.cs.ucla.edu/click/docs">内部ツールの一覧</a>から読める。オフラインでの閲覧は<a class="replace_me" href="#offline-element-doc"></a>を参照のこと。ただしDriverのmanを初期に参照することは無い。またapropos Classifierとすると、manの全文検索が行える。
      </p>
      <h5>
        API(doxygen)
      </h5>
      <p>
        オンラインでは<a href="http://read.cs.ucla.edu/click/doxygen/">API documentation</a>から読める。このドキュメントはclick/doc以下に入っているので、doxygenというプログラムで生成すればオフラインでも読める。方法は<a class="replace_me" href="#offline-doxygen-doc"></a>を参照のこと。
      </p>
      <h4>
        Linuxの実行中情報
      </h4>
      <ul>
        <li>
          ifconfig   # NICのIPアドレス、MACアドレス、ONかOFFかを確認する。
        </li>
        <li>
          netstat    # 現在ソケット通信を行っているプログラムを表示する。
        </li>
        <li>
          route      # ルーティング表を表示する。インターネットから切り離して数台で実験する時に、静的ルーティングを設定するために使う。
        </li>
        <li>
          traceroute # パケットが届くまでに通るルーターを一覧表示する。
        </li>
        <li>
          strace     # Linuxのみ。プログラム内で呼び出したシステムコールを表示する。ソースコードを読むよりも早く実行内容を理解できるケースがある。
        </li>
        <li>
          wireshark  # パケットキャプチャ。きちんとNICに届いているかなどを確認できる。
        </li>
        <li>
          tcpdump    # 同上。遠隔マシンではwiresharkより役立つ？
        </li>
      </ul>
      <h3>
        作ってみる
      </h3>
      <h4 id="null-element">
        何もしないNullElement
      </h4>
      <p>
        自作のelementを使う場合、言っておかないと確実に誰もがハマって数時間を費やす注意点は<strong>./configureのときに--enable-localオプションをつけておく必要がある</strong>ということである。これをしておかないと以下でclick/elements/local以下に自作のelementを追加しても、sudo make installされたとき（clickが、その自作のelementを含めてプログラムを再構成するとき）にコンパイルされない。
      </p>
      <p>
        このチュートリアルでは<a class="replace_me" href="#install-click"></a>の章で既にそれに言及しているため問題はないだろうが、仮にそのオプションを指定していない場合は上記のURLの./configure --prefix=$HOMEを実行する前の作業から、設定をやり直す必要が生じる。
      </p>
      <p>
        click/elements/local以外のディレクトリでも作る方法を以下でも解説するが、まだ一部しか理解していない(EXTRA_DRIVER_OBJSのような、外部ライブラリを使う際に違いが生じるようである)。
      </p>
      <p>
        自作elementを追加したあとは、毎回
      </p>
      <pre class="console">make elemlist　     # 「sudo make install」でコンパイルされるelementの一覧(click/elements.conf)を書き換えるコマンド。
sudo make install  # elements.confに従って自作elementをコンパイルする。C++の文法ミスなどはここでエラーが出る。</pre>
      <p>
        の2つのコマンドを実行する(elements/local以下に追加した場合はelemlistしなくても良かった気が...未確認)。それ以後、click myConfig.clickなどのコンフファイルの中でその自作elementを利用可能になる。（myConfig.clickを実行している最中に落ちた場合は、コンフィグファイルのelementの配置順の誤解、もしくは例外処理の不足が生じてエラーを出していると思われる。man 1 clickにあるようにCLICK_BACKTRACEをONにすると原因が掴めるかも？未確認）
      </p>
      <p>
        以上に書いたような「新しいelementの作り方」の概要は<a href="http://www.read.cs.ucla.edu/click/faq#creating-your-own-elements">FAQ</a>にまとまっている。
      </p>
      <p>
        class_name(), port_count()は必ず実装する。push(), pull(), simple_action()はそれぞれ、push, pull, agnosticなoutput portを持つelementがそれぞれ実装する（３つのうち、どれか１つだけということである）。以上を踏まえて、click/elements/standard/nullelement.ccを参考に作る。
      </p>
      <p>
        更に詳しい情報は、<a href="http://www.read.cs.ucla.edu/click/doxygen/class_element.html">こちら</a>にまとまっている。
      </p>
      <p>
        なお、ドキュメントには書いてないのだがC++をある程度知っている場合によく陥る注意点として、<strong>ドキュメントで指定された関数について、余分にconstをつけてはいけない</strong>というものを挙げたい。これは、例えば<strong>int Element::configure( Vector< String > & conf, ErrorHandler * errh )</strong>について、 引数confを変更しないからと<strong>int Element::configure( const Vector< String > & conf, ErrorHandler * errh )</strong>と変更してしまうと、これは全く別の関数を宣言したことになるため、必要なインターフェイスが実装されていないということでエラーが出る。エラーメッセージが直感的でないため、このタイプのミスは事前に存在を知っておいたほうがよい。
      </p>
      <h4 id="api-element">
        内部APIを用いるelement
      </h4>
      <p>
        新しいelementをClickで実装する際はAPIの理解が必須である。Clickは一般的なC++プログラマなら普通使うであろう「C++のSTLに含まれるStringなどの標準ライブラリクラス」を使わず、独自にそれらのStringクラスに相当するものをを実装し直して使うなどしており、呼び出す関数名や返ってくる戻り値などについてClick内部のソースコードを見ながら逐一確認する必要があるからだ。
      </p>
      <p>
        API（クラスとそのメンバ関数群）はhttp://read.cs.ucla.edu/click/doxygen/classes.html にまとまっている。実際にはPacket.hhの説明を読んだ後、右上の虫眼鏡で検索したり、各タブを利用することでAPIを探していく。
      </p>
      <p>
        なおこのAPIドキュメントはオフライン閲覧もできる。<a class="replace_me" href="#offline-doxygen-doc"></a>を参照のこと。
      </p>
      <h4>
        外部ライブラリを呼び出す
      </h4>
      <p>
        coming soon
      </p>
      <h4>
        elements/local/以外で自作エレメント
      </h4>
      <p>
        click/etc/samplepackage/READMEにあるが、コマンドの実行順序が読み取れない。不完全だが、以下までは把握した。なお、<strong>事前にclick/etc/samplepackage以下のファイルを新規フォルダにコピーしておく</strong>とよい。
      </p>
      <pre class="console">pwd                # ->  ~/click/etc/samplepackage    
ls                 # ->  configure.ac   Makefile.in   README   sampleelt.cc   sampleelt.hh   test.click

autoconf           # -> configure.acに基づき、configureコマンドが作成される。
\./configure        # -> Makefile.inに基づき、Makefileファイルが作成される。
make elemlist      # -> .ccファイル内のEXPORT_ELEMENTなどから　sample-{k,m}elements.conf　と　sample-uelem.mkが作成される。
make               # -> sample.koなど大量のオブジェクトファイルが作成される。
sudo make install  # -> sample.uoなどが無事に/usr/bin/以下あたりにインストールされる。これによって初めて以下のコマンドが成功する。
click test.click   # -> test.click: 3: While initializing 'test :: SamplePackageElement':
Successfully linked with package!</pre>
      <p>
        しかし、このようにパッケージとして自作エレメントのインストールを行った場合、プロファイリングコマンドgprofの結果(デフォルトではgprof /usr/local/bin/click gmon.out)に
      </p>
      <strong>パッケージ内のエレメントが現れない(gprofで計測ができない)</strong>
      <p>
        ことに注意する。より正確には、Clickバイナリのインストール即ち
      </p>
      <pre class="console">pwd # Clickフォルダのルート<div>./configure CXXFLAGS="-pg" LDFLAGS="-pg" --disable-linuxmodule --enable-local</div><make></make></pre>
      <p>
        の際に、このpgがどうやらパッケージ内でmakeをしたときには適用されない模様である。解決策は探せばあるだろうが、とりあえずパッケージ内のエレメントをelements/local以下に移してコンパイルすることでgprofの結果に自作エレメントの関数が現れるようになった。
      </p>
      <h4>
        独自の.oファイルを利用する
      </h4>
      <p>
        configure.in内のEXTRA_DRIVER_OBJSをセットしよう。ただし、samplepackageのように別パッケージで作った場合、sudo makeは成功しても.clickファイルの実行時にundefined symbolエラーとなる。elements/local以下に置いた場合に.clickの実行まで含めて成功することは確認した。
      </p>
      <h4>
        ElementClassでエレメントを作る
      </h4>
      <p>
        「フォワーディング」とは、あるNICから入ってきたパケットを別のNICから送信する動作のことだ。主としてルータが行ない、特にIPパケットの場合はIPフォワーディングと呼称される。
      </p>
      <p>
        Linux環境では、/proc/sys/net/ipv4/ip_forwardの値を1にすると、自動的にIPフォワーディングの機能が有効になる(sudo sh -c "echo 1 > /proc/sys/net/ipv4/ip_forward"とすればよい。元に戻すにはsudo sh -c "echo 0 > /proc/sys/net/ipv4/ip_forward" とすればよい。)。これにおよそ相当する動作を、Clickのエレメントで実装してみると以下のようになる。
      </p>
      <pre class="console">elementclass MacRewriter{ $src, $dst |
  input                              // assume with ethernet header
  -> Print(____________BEFORE_REWRITING____________, MAXLENGTH 100)
  -> Strip(14)                       // remove ether header
  -> EtherEncap(0x0800, $src, $dst)  // attach new ether header
  -> Print([$src]->[$dst], MAXLENGTH 100)
  -> output
}

FromDevice(eth0)
-> MacRewriter(33:33:33:33:33:33 /*src*/, 44:44:44:44:44:44 /*dst*/)
-> Queue -> ToDevice(eth1);

// backward
FromDevice(eth1)
\-> MacRewriter(22:22:22:22:22:22, 11:11:11:11:11:11)
\-> Queue -> ToDevice(eth0);</pre><img src="img/ip_forwarding.png">
      <p>
        上図のような状況で、Machine2上で上記のClickソフトウェアルーターをClickコマンドで起動した場合、10.0.0.1/8と11.0.0.2/8という異なるネットワーク間でのホストでデータのやりとりができる。Machine1からpingが通るかping 11.0.0.2/8をして試してみよう。もっともこの場合、隣り合うマシンのMACアドレスを知っていなければならず、あまり現実的ではない（？）。
      </p>
      <p>
        なおVirtualBoxを使っている場合はVboxManageのclonevdiコマンドを用いれば、複数台のVMの用意が楽になる。<a class="replace_me" href="#how-to-copy-virtual-machine"></a>を参照のこと。
      </p>
      <h4>
        エレメントにTelnet接続する
      </h4>
      <p>
        エレメントのマニュアル（man Printなど）には、MAXLENGTHなどのパラメタを列挙しているDESCRIPTIONとは別に、<strong>ELEMENT HANDLERS</strong>という項目がある。この項目に記載されたデータは、Clickの実行プロセスにTelnet接続することで、実行時に読み取ることができる。
      </p>
      <pre class="console">cat orera_wa_gomibako_yukisa.click # on the first terminal
> FromDevice(en0) -> Discard();
sudo click --port 777  orera_wa_gomibako_yukisa.click

telnet localhost 777               # on the second terminal

read list    # 稼働中のエレメントを一覧表示する
200 Read handler 'list' OK
DATA 53
3
FromDevice@1
Discard@2
click_driver@@ControlSocket

read Discard@2.count  # Discardされたパケット数を確認する
200 Read handler 'Discard@2.count' OK
DATA 3
177</pre>
      <p>
        何かと役立つだろう。
      </p>
      <h3>
        更に調べる(まだ未整理)
      </h3>
      <h4 id="click-architecture-map">
        Clickの使い方を整理する
      </h4>
      <p>
        　ここまでで紹介した様々な使用法を表として整理した。
      </p>
      <table class="table table-striped table-condensed table-bordered">
        <tr>
          <th>
            追加・変更するコード
          </th>
          <th>
            手早く設定を変更できるか
          </th>
          <th>
            新機能が柔軟に追加できるか
          </th>
          <th>
            管理のしやすさ
          </th>
        </tr>
        <tr>
          <td>
            Configuration String
          </td>
          <td>
            ◎。ドキュメントを読んで.clickを書き換えるだけ。C++の知識が不要
          </td>
          <td>
            ✖。ただし既存エレメントの組み合わせで従来型ルータを作るのは柔軟かつ高速にできるのはよい。
          </td>
          <td>
            ◯。ただし次第に.clickファイルが溢れてくる
          </td>
        </tr>
        <tr>
          <td>
            elements/local内の自作エレメント
          </td>
          <td class="vertical_center" rowspan="2">
            ◯。ただし最初はAPIドキュメントをかなり読む必要がある。慣れてくるとかなり早くなる。C++の知識をかなり前提としている
          </td>
          <td>
            ◎。EXTRA_DRIVER_OBJSが使えるので事実上どんな既存のLinuxプログラムとも組み合わせられる。./configure時に-pgなどを設定できるため、デバッグや性能測定も可能
          </td>
          <td>
            ✖。他のエレメントと混ざって見にくい。複数プロジェクトで使う場合は考えたくないほど。
          </td>
        </tr>
        <tr>
          <td>
            パッケージ化した自作エレメント群
          </td>
          <td>
            △。EXTRA_DRIVER_OBJSが使えなかったり、gprofに必要な-pgフラグをどのMakefileにつければ良いのかが分からない現状では、どこかでelements/localに移す必要が出てくる。
          </td>
          <td>
            ◎。プロジェクトごとに管理可能
          </td>
        </tr>
      </table>
      <h4 id="two-arguments">
        elementの2引数()
      </h4>
      <pre>もう一つelementという概念の設計思想として指摘しておくべき点としては、elementは引数にあたるものを２種類取るということである。その２つとはパケットとconfiguration stringである。これは、コンフファイルを書く最終段階でも、後述する「新しいelementを作る過程」でも、常に2種類を意識する必要がある。全然違う性格を持つからである。

【コンフファイルを書く最終段階において】
たとえば　FromDevice(eth0) -> Print(ok) -> Discard;　という1行だけのコンフファイルで考えてみる。
configuration stringは関数の引数のような形式で渡されている。たとえばFromDeviceというelementにはeth0、Printというelementにはokが渡されている。
一方でパケットは、 -> という（矢印を模した）記号の前でプロセスされたものが引数として渡されている。　
->　が前に存在していないFromDeviceは -> ではなくconfiguration stringによって受け渡しが行われている。ここも忘れやすいので注意。

【新しいelementを作る過程において】
パケットはソースコード中ではPrint::simple_action(Packet *p){といったように関数の引数として渡されている。
configuration stringは対応する.ccファイルの関数configure()の中で
if (Args(conf, this, errh)
   .read_p("MAXLENGTH", bytes)
   .read("LENGTH", Args::deprecated, bytes)
   .read("TIMESTAMP", timestamp)
   .complete() < 0)
return -1;
のように、パースされたのちにsimple_actionなどのパケット処理を行う別の関数内で使えるようになっている。

(simple_action()は、そのelementのもとにパケットが来た際に自動で（イベントドリブンで）呼び出される関数である。)


一方で、elementはoutput portsの数自体はいくつあっても良いのに、他のelementに渡す物体としてはパケットだけというのは面白い。configuration stringを（コンフファイルにおける）後続のelementに渡すようなことは基本的には行われていないのである。パケットはカスケードのように次々に後続のelementに渡されていく一方で、configuration stringはそのelementだけが参照できるデータである。このように、clickにおけるデータの受け渡しには設計上の特徴がある。</pre>
      <h4>
        StringとStringAccumを学ぶ
      </h4>
      <p>
        StringAccumは、Click内部で文字列の連結をかんたんに行うためのクラスである。
      </p>
      <p>
        そして、StringAccumクラスを学ぶのに最適なソースコードはズバリelements/userlevel/kernelfilter.cc内のdevice_filter()である。この関数は、実はこれまでずっと使ってきたFromDevice.uエレメント(ユーザーレベルのFromDevice)エレメントのSNIFFERというオプションをfalseにした際に呼び出される。まず、<a href="http://www.read.cs.ucla.edu/click/elements/fromdevice.u#description">FromDevice.uエレメントのSNIFFERオプションの説明</a>を読んでみよう。
      </p>
      <pre>SNIFFER
Boolean. Specifies whether FromDevice should run in sniffer mode. In non-sniffer mode, FromDevice installs KernelFilter filtering rules to block the kernel from handling any packets arriving on device DEVNAME. Default is true (sniffer mode).
(大意：
SNIFFER<br>
FromDevice(eth0, SNIFFER true) もしくは FromDevice(eth0, SNIFFER false)  のように使う。デフォルトはtrue。falseにすると、.clickファイルを動かしたときに自動的にKernelFilterエレメントのメソッドが呼び出され、eth0に届いた全てのパケットをLinuxカーネルが扱うことを防ぐ。)</pre>
      <p>
        要するに、FromDeviceエレメントのオプションとして、KernelFilterエレメントの一部機能が転用されている。この呼び出される「KernelFilterエレメントのメソッド」が上述のKernelFilter::device_filter()である。今度は、KernelFilterエレメントの説明(man KernelFilter、大文字を忘れずに)を読んでみよう。
      </p>
      <pre>DESCRIPTION
The KernelFilter element installs filter rules in the kernel to stop the kernel from handling certain types of packets. Use this in combination with FromDevice.u to handle packets in user-level Click configurations. KernelFilter uses iptables(1) to install filters; if your system does not support iptables(1), KernelFilter will fail. Normally KernelFilter uses either /sbin/iptables or /usr/sbin/iptables. To override this use the IPTABLES_COMMAND keyword argument. KernelFilter uninstalls its firewall rules when Click shuts down. If Click shuts down uncleanly, for instance because of a segmentation fault or 'kill -9', then the rules will remain in place, and you'll have to remove them yourself.
(大意:<br>
KernelFilterエレメントは単にLinuxでファイヤーウォールを設定する際に使われる iptables コマンドのラッパーである。/sbin/iptables もしくは /usr/sbin/iptables にあるiptablesを、execl()システムコールで実行しているだけである。その２箇所のどちらにもない場合はもちろんエラーとなる。<br><br>
KernelFilterによる呼出でインストールされたファイヤーウォールのフィルタリングルールすなわち<br>
"/sbin/iptables -A INPUT -i eth0 -j DROP"  (append a rule)<br>
などは、ClickのプログラムをCtrl - Cなどで終了させた際に<br>
"/sbin/iptables -D INPUT -i eth0 -j DROP"  (drop a rule)<br>
が自動的に呼ばれて消去される。ただしsegmentation faultなどで落ちた場合は残り続けるので注意。<br>
上のコマンドを見て分かるように、残ってしまうとeth0に届いたパケットは全て捨てられてしまうので、何も通信ができない。</pre>
      <p>
        この「Clickが動いている時だけ適用されるフィルタリングルール」については、例えば以下のように確認ができる。
      </p>
      <img src="img/view_iptables.png">
      <p>
        Clickで作ったルーターがバックグラウンド(&)で動いている間だけ、DROP all -- anywhere anywhere なるとても強いフィルタリングルールが適用されていることが分かる。なおこのようなシェルプログラミングに苦手意識があるならば、"A practical guide to Linux commands, editors, and shell programming"(Mark G. Sobell, 2012)のChapter 2, 3, 4, 5, 8, 10を勧める。
      </p>
      <p>
        さて、ここまで理解した上でKernelFilter::device_filter()を見てみると、内容は一目瞭然である。StringAccumのインスタンスに対して、"/sbin/iptables" か "/usr/sbin/iptables"のどちらかの文字列を<<演算子で読み込んで、その後ろに引数を読み込んで、上述のiptablesの実行コマンド文字列を用意しているだけである。この関数のソースコードからは、以下のことが学べる。
      </p>
      <ol>
        <li>
          StringAccumクラスは&lt;&lt;演算子で文字列を連結できる。
        </li>
        <li>
          StringAccum::take_string()関数で(Click独自の)Stringクラスに変換できる。
        </li>
        <li>
          String.c_str()でchar *に変換できる。すなわちexecl()などのシステムコールに渡せる形にやっとここでなる。
        </li>
      </ol>
      <h4 id="click-detail-by-author">
        作者による内部解説
      </h4>
      <p>
        <a href="http://www.read.cs.ucla.edu/click/clickunderhood">ここ</a>が恐らく一番詳しい。
      </p>
      <h4 id="click-mailing-list">
        更に突っ込んだ話題はメーリスを漁る
      </h4>
      <p>
        たとえば"global variable site:pdos.csail.mit.edu"で検索すると、<a href="http://pdos.csail.mit.edu/pipermail/click/2009-February/007659.html">２つのエレメント間でデータを共有するにはグローバル変数で良いが、果たしてそれらのエレメントが同じコンフィグファイル内で複数回使われたらどうなるのか教えて欲しい</a>という話題が出てくる。残念ながらリンク先からはその答えが見つけられないが、自分がいま探しているのが２つのエレメント間での共有だけであれば、このページを読むだけでグローバル変数を.ccファイルに書けばよいと勘付けるだろう。
      </p>
      <p>
        また、gprofでクリックのエレメントの速度測定が可能かなどの話題についても作者が既にメーリス内で答えている。（userlevel Clickでは可能で、Kernel Levelではoprofileを用いる）
      </p>
      <h4>
        その他まだ未整理の話題
      </h4>
      <h5>
        複数element間でのデータの受け渡し
      </h5>
      <p>
        ３つの方法を思いついた。
      </p>
      <ul>
        <li>
          ColorというClick内部の空き場所を使う
        </li>
        <li>
          http://www.read.cs.ucla.edu/click/docs/language#configuration-parametersの方法を使う。例として、click/conf/mazu-net.clickでは<pre>elementclass GatewayDevice {
  $device |
  from :: FromDevice($device)
  -> output;
  input -> q :: Queue(1024)
  -> to :: ToDevice($device);
  ScheduleInfo(from .1, to 1);
}</pre>のように$deviceが2回参照されている。
        </li>
        <li>
          .cc内でグローバル変数を宣言し、もう片方の.cc内でexternして受け取る。ただしこうやった場合に、同じエレメントが複数個.clickにあった場合、どのようなことが起きるのかは未確認。
        </li>
      </ul>
      <h5>
        configuration fileの作成方法
      </h5>
      <pre class="console">click/conf/test-device.clickというコンフファイルの実行内容は以下の1行のみである。

FromDevice(eth0) -> Print(ok) -> Discard;

これは、eth0というネットワークインターフェイス(以下NIC)からのパケットを全て「複製」し、okというラベルと共にそのパケットの「先頭何バイトか」を標準出力に表示したあと、そのパケットを「破棄する」というルーターに等しい。
ここで一つ注意すべきなのは、「　」で括った語句の意味内容は、実際にはこのコンフファイルを読んだだけでは理解できない。「複製」と言うが、では元々NICに入ってきたパケット（複製元のパケット）はどうなっているのか。「先頭何バイトか」と言うがバイト数を変えることはできないのか。「破棄する」というが複製元のパケットも破棄するのか、それとも複製後のパケットだけを破棄するのかどうなのか。clickのコンフファイルは見た目の簡潔さを重視しているため、コンフファイルを見ただけではこれらの実行内容を調べることはできない。

これらの実行内容を調べる手段は２つ存在する。

１．公式サイトのelements (http://www.read.cs.ucla.edu/click/elements)のページにある英語という自然言語で読む。
２．click/elements以下にあるstandard/print.ccなどを直に読んで、処理内容をプログラミング言語という形式言語から読み解く。

当然ながら2.の方が正確ではあるが、同時に残念ながら2.の方が難易度が高い。上述した「stringを自分で実装し直している」という比較的珍しい方針からも分かるように、Click自体はかなり高度なプログラミングテクニックを用いて記述されているため、線形に目を通したのではとても読めないコードが満載である。私もctagsなどのソースコード閲覧支援プログラムを用いて読解を試みているが全然歯が立たない。そのため、2.に挑む場合は以下のどちらかの理解支援方法が必要になるだろう。

A.プログラミングの有識者に問い合わせる。究極的には作者Eddie Cohler氏に聞く。
B.各種C++ライブラリの参考書とネットワークの専門書を頼りに理解していく。

どちらも「必ず通用する、何度でも行える」というものではない。

以上のことから、1.の公式サイトの記述を読むことがClickのelementsの理解方法としてふさわしいと思われる。ただし上述のelementsのページは辞書が好きな人なら分かると思うが入門書や講義調に描かれている訳ではなくあくまで「誰かにとっての必要事項（めったに使わない変数の設定なども含まれる）」を並べ立てている、いわば博物誌や標本のような情報の並べ方をしているので、通して全て読むといった形の読書が通じるものではない。以上のことから、Clickを勉強する際には常にelementsのページを横に開いておくスタイルが望ましいと思われる。

elementsのページを飛ばし読みしながら、自分がルーターに付けたい機能を実現できるelementsはどれかを選択していく。
これが「◆clickにおけるconfiguration fileにおいて」の最終段階として挙げた作業の、一つ前の作業だと思われる。これを作業Bと以下では呼称する。

そして仮に、そのようなelementsを（まだan elementとして存在していない、もしくは既存のelementsを繋げれば求めている機能が実現されることに気付けなかった）などの理由で見出せなかった場合、作業Bと並行して「自分で新しいelementを実装する」という作業Cが必要となる。</pre>
      <h5>
        以上に出てこない関数など
      </h5>
      <p>
        click/ns/nsclick.ccで定義される引数なしのclick_random()がそれである。このような関数の定義元を探す場合、ソースコードにタグ付けするcscopeや<a href="http://ctags.sourceforge.net/">ctags</a>といったソフトを使うしかないと思われる。私はsublime text 3のctagsパッケージにずいぶん助けられている。
      </p>
      <h5 id="offline-element-doc">
        オフラインでエレメントのdocを読む
      </h5>
      <p>
        man FromDeviceなどとすると読める。なお、Linuxのネットワークコマンド（tcpdumpなど）がクリックのどこで使われているかを知るには、apropos tcpdumpなどとすると一覧できて便利かと思われる。
      </p>
      <h5 id="offline-doxygen-doc">
        オフラインでAPIドキュメントを読む
      </h5>
      <p Mac="" OS="" Xの場合=""></p>
      <pre class="console">brew install doxygen     # doxygenを何らかの方法でインストール
cd (Clickのrootディレクトリ)/doc
doxygen -u               # obsoleteになった設定事項を消去。必要ないかもしれない。
doxygen                  # ドキュメントをhtmlで生成
open html/index.html     # できあがったhtml/index.htmlから閲覧する</pre>
      <p>
        手元の環境では、(Clickのrootディレクトリ)/doc/Doxyfile内で、
      </p>
      <ul>
        <li>
          変数DOC_FONTNAME（使われるフォント）を変更
        </li>
        <li>
          変数INPUTのパスを全て１階層上に変更(ドキュメントを含むソースコードが存在するフォルダ一覧。)<br>　たとえば、include/click ならば ../include/clickにする。
        </li>
      </ul>
      <p>
        以上を行うと環境によっては Check your TeX installation! という大量のエラーが表示されるが、.htmlのドキュメントファイルについては正常に生成される。ドキュメントのpdf化については個々人で対応されたい。
      </p>
      <h5>
        miscellaneous
      </h5>
      <ol>
        <li>
          click(1)にチラっと書いてあるCLICK_BACKTRACE怪しい これをONにすればエラー特定に役立つのではないか？
        </li>
        <li>
          click(5)は言語について書いてる
        </li>
      </ol>
      <h5>
        clickの位置付け
      </h5>
      <pre class="console">（誤認の可能性が高い。よってこの項目の記述内容は容易に変動する。）
ClickはUnix系OSにおけるネットワーク系コマンド群をKohler氏の思想によってまとめ上げ、機能を追加し、さらに拡張可能にした巨大なプログラムである。

その複雑化の制御の過程で単に標準入力のコマンドのような設定項目の羅列や項目の羅列である設定ファイルではなく、DSLのような特性が生じた。
(※DSL…Domain Specific Languageドメイン固有言語。特定のタスク遂行に特化した言語。コンパイル支援におけるmake、文章構造化におけるHTMLなどがその例。)
Kohler氏の研究興味分野にプログラミング言語が入っていることは興味深い（networks, programming languagesと並ぶのは比較的珍しい）。

その結果としてネットワークの設定が標準入力コマンドのオプション引数やいわゆる設定ファイルよりも遥かに人間の思考に沿ったかたちで記述・構築可能になった。これがClickの思想的な業績であると私は考える。この発想は東京大学・中尾彰宏教授のToy-Block Networkingなどの研究に影響を与えたと想定される。

Clickは今まで述べてきたようにelements間については厳格な形式制限があるが、ソースコードのレベルにおいては様々なライブラリを柔軟に取り込むことができる。
STLの標準ライブラリを取り込むことも可能であるし、たとえばnetstatの機能を内部に追加するなども(更に高度になるが)可能である。
実際、ClickのKernelFilterエレメントはiptablesコマンドをそのまま呼び出している。</pre>
      <h3 id="references">
        参考文献
      </h3>
      <ul>
        <li>
          <a href="http://www.gnu.org/software/make/manual/make.html">GNUによる公式マニュアル</a> ... makeはググって情報を探すことに向いていない。Clickを学んでいてmakeについて疑問が生じたら、このマニュアルかAndrew Oramの『make 改訂版』を参照することを推奨する。
        </li>
        <li>
          『ストラウストラップのプログラミング入門』 ... const参照の意義についての説明は感動。
        </li>
        <li>
          『詳説 Cポインタ』 ... 2章まで読むだけでも、ポインタの概要が分かる。
        </li>
        <li>
          『Linux Programming Interface』の41章 ... 静的/動的リンクについて詳細な説明がなされている。リンクのエラーはググっても解決策が出てこない（もしくはとても読みにくい）ことが多く、先に全体を知ってしまったほうが無難である。
        </li>
        <li>
          『Linuxネットワークプログラミングバイブル』 ... ソケット通信の初歩を大量のサンプルコードと共に学べる。
        </li>
      </ul>
      <h4>
        その他
      </h4>
      <ul>
        <li class="no_replace_please">
          誤植や誤解などありましたら<a href="https://github.com/caprice-j/click_tutorial_in_Japanese">github</a>へお願いします
        </li>
      </ul>
      <h4>
        使用ライブラリ等
      </h4>
      <ul>
        <li>
          <a href="http://jquery.com/">jQuery 2.1.0</a>未だにソースコード読んでいない
        </li>
        <li>
          <a href="http://getbootstrap.com/2.3.2/">twitter-bootstrap 2.3.2</a>世間では3.x系も出ているらしいが2.x系のデザインの方が好きである
        </li>
        <li>
          <a href="http://gregfranko.com/jquery.tocify.js/">jquery.tocify.js 1.9.0</a>現在位置を表示してくれる目次というのは素晴らしい
        </li>
        <li>
          <a href="http://fortawesome.github.io/Font-Awesome/">Font Awesome 4.1.0</a>アイコンに色を付けたかった
        </li>
        <li>
          <a href="http://alphapixels.com/prepros/">Prepros 4.2.0</a>.slimと.scssを.htmlにコンパイルするアプリ　slimの存在を教えて下さったT先輩に感謝
        </li>
      </ul>
      <h4>
        このチュートリアルに付けたい機能
      </h4>
      <ul>
        <li>
          目次 ... 済(ライブラリ)
        </li>
        <li>
          辞書 ... 自作済　まだちょっと使いにくい 
          <ul>
            <li>
              端で切れるのを改善したい
            </li>
            <li>
              .gzの説明が切れるのを直したい
            </li>
            <li>
              複数表示したままにしたい
            </li>
            <li>
              aタグ内の文字の扱いを改良したい(現状それが原因でバグが起こるため文章を変えて回避中)
            </li>
          </ul>
        </li>
        <li>
          画像gif化 ... 動いたほうが分かりやすい
        </li>
      </ul>
      <h4>
        開発履歴
      </h4>
      <p>
        2014年
      </p>
      <ul>
        <li>
          0324  何となく書き始める
        </li>
        <li>
          0325  公開したら.txtですら案外好評だったので続ける気になる
        </li>
        <li>
          0402  目次をフレーム化するためにhtml化
        </li>
        <li>
          0530  IP forwardingの項を追加
        </li>
        <li>
          0603  FAQの存在を発見、リンクに追加
        </li>
        <li>
          0604  Haml, Scssで全て書き直した
        </li>
        <li>
          0605  指摘を受けて修正　誤：element/nullelement.cc 　正： element/standard/nullelement.cc
        </li>
        <li>
          0629  hamlをslimで書き直した
        </li>
        <li>
          0712  jquery.tocify.jsを利用して動的な目次を作成
        </li>
        <li>
          0713  辞書機能を追加、4章までの説明を大きく追加
        </li>
      </ul>
      <script type="text/javascript">
        $(function() {
            //Calls the tocify method on your HTML div.
            $("#left_frame").tocify({showEffect: "none"});
        });
      </script>
    </div>
  </body>
</haml>
