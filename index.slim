doctype html
haml lang="ja"
  head
    meta charset="UTF-8"
    link rel="stylesheet" href="css/basic.css"
    link rel="stylesheet" href="jquery.tocify.css"
    link rel="stylesheet" href="css/bootstrap-2.3.2.css"
    script(src="js/jquery-2.1.0.js")
    script(src="js/jquery-ui-1.10.4.custom.js")
    / script(src="js/jquery.tocify.js")
    script(src="js/bootstrap-2.3.2.js")
    script(src="js/tableofcontents.js")
    title ClickJapanese
  body
    #left_frame
      #manualIndexExpandButton
      #table-of-contents-div
        / generated by tableofcontents.js
    #right_frame.tocChild
      header#manualTitle Click Tutorial in Japanese ver.0.4
      hr


      h3#what-is-click Clickとは
      ul
        li ルーターの機能を記述するためのC++の巨大なライブラリである。
        li Unix系OS(Linux, Android。Mac OS Xでも一部動く)上で動く。
        li 拡張する（ライブラリ内に無い、自分の欲しい機能を作る）にはC++の知識がかなり必要とされる。
        li
          a(href="http://read.cs.ucla.edu/click/") 公式サイト
          | では大文字でClickと表記されているが、簡単のためclickとする。

      h3#install-click インストールする
      p git, make, g++がインストールされているとする。g++はclangでも動くはずである。
      pre.console
        | git clone https://github.com/kohler/click.git
          cd click            # change directory
          \./configure --disable-linuxmodule --enable-local
          make                # ./userlevel以下にClickのバイナリを作る
          sudo make install   # 作られたバイナリを適切な場所へ移動(install)させる（下注１）
      ol
        li 注１
        li PATH(端末からコマンドを入力したときに探す場所)に含まれる/usr/local/binにはClickの実行バイナリ
        li "//usr/local/libにはlibclick.aなどの静的ライブラリ
        li "//usr/share/include(g++がインクルード指定のファイルを探し始める場所)にはヘッダファイル
      p がインストールされる。

      p 以上でインストールは終了である。
      p --disable-linuxmoduleは付けなくても成功すれば構わない。無いとインストールが失敗するLinuxのディストリビューションがある。また当然ながらMac OS上では無いと必ず以下のように失敗する。

      pre.errorConsole
        | configure: error:
          =========================================

          Can't find /usr/src/linux, so I can't compile the linuxmodule driver!
          (You may need the --with-linux=DIR option.)

          =========================================
      p
        = "--enable-localについては無くても上記のsudo make installまでは成功するが、"
        a(href="http://read.cs.ucla.edu/click/faq#creating-your-own-elements") 公式FAQ
        に記載があるように、のちのち自作機能を追加する際に必要である。オンにしておいたほうが無難だろう。

      h4 注意: --disable-linuxmoduleによって使えなくなるものがある
      p sudo make installによって/usr/local/bin以下にClickのバイナリがインストールされた。これでようやくClickによるソフトウェアルーター(正体は,大量の設定項目(Configuration String)が渡されたClickバイナリ内の_main関数...のはず)が起動できる...と行きたいところだが、上記のように--disable-linuxmoduleフラグを付けて./configureした場合、linuxmoduleというプログラム部分は/usr/local/以下にインストールされない。
      p この状態で、例えばconf/udpcount.clickというルーター設定で動かしてみると、以下のエラーが表示される。
      pre.errorConsole
        | $sudo click conf/udpcount.click
          conf/udpcount.click:17: unknown element class 'PollDevice'
          conf/udpcount.click:19: unknown element class 'ToHost'
      p これから、PollDeviceとToHostというlinuxmoduleに含まれるエレメントがインストールされていないと分かる。

      h4 VirtualBoxのネットワークについて
      p 以下は僕の理解である。
      pre.console
        | 種類/相手先　　　インターネット　　ホストOS　　　別のゲストOS
          NAT　　　　　　　O　　　　　　　　O　　　　　　　？
          Host-only        X             O            O
          Internal         X             X            O
      h4 VirtualBoxのマシンを複製する
      p ネットワークの実験では3台や4台のマシンが欲しくなることも多い。その際にOS、Wireshark、Clickなどを一台ずつ個別にセットするのは手間である。VirtualBoxでは、１台必要な環境を仮想ハードディスクにインストールしてしまえばその.vdiファイルを簡単に流用できる。
      p 単純にコピペして、VBoxManageのsethduuidでUUIDを変更するのでもよいが、clonevdiコマンドを用いれば1手間で済む。ただしHDDが使用中だと以下のエラーを出して失敗するため、Save the machine stateでもいいので、一度止めてから再実行する。
      pre.errorConsole
        | hst@pcname ~/click $ VBoxManage clonevdi "/Users/hst/VirtualBox VMs/vm3/server.vdi" "/Users/hst/VirtualBox VMs/vm4/clonedserver.vdi"
          VBoxManage: error: Failed to lock source media '/Users/hst/VirtualBox VMs/vm3/server.vdi'
          VBoxManage: error: Details: code VBOX_E_INVALID_OBJECT_STATE (0x80bb0007), component Medium, interface IMedium, callee nsISupports
          VBoxManage: error: Context: 'CloneTo(dstDisk, ComSafeArrayAsInParam(l_variants), NULL, progress.asOutParam())' at line 740 of file VBoxManageDisk.cpp


      h3 試してみる
      h4#hello-world Hello World相当のことを行う
      p
        a(href="http://www.read.cs.ucla.edu/click/tutorial1#preparation") 公式サイトのチュートリアル
        | の簡易版である。
      p 以下では、断りがなければClickのルートディレクトリ(git cloneされたものの中で最上層のディレクトリ)に居るとする。
      pre.console
        | click conf/test.click
          ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369
          ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369
          ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369
          ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369
          ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369
      p となればHello World成功である。まだconf/test.clickの中身は理解せずとも問題ない。

      h4#test-device 既存のClickルータを動かす
      pre.console
        sudo click conf/test-device.click
      p とした上で、例えばブラウザでWebページを開くなどするとeth0に届いたパケットの先頭数十バイトが表示される。eth0がないマシン上の場合は適宜変更するとよい(ifconfigで調べたのち、例えば開発機ではtest-device.clickのeth0をen0に書き換えた)。

      h4#change-string Configuration Stringを変えてみる
      p Configuration Stringの定義は後述する。エディタでconf/test.clickを開いて、LIMIT 5の部分をLIMIT 4にしてみる。そしてclick test.clickとして実行すると、
      pre.console
        | click conf/test.click
          ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369
          ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369
          ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369
          ok:    40 | 45000028 00000000 401177c3 01000001 02000002 13691369
      p のように、先ほど5回表示されたパケットの先頭バイトが、4回のみ表示されるようになった。
      p 同様にconf/test-device.clickをエディタで開き、Print(ok)をPrint(noProblem)とすると、先ほど出力でokと書かれていた場所にnoProblemと表示される。一方で、Print(no problem)とすると、
      pre.errorConsole
        click conf/test.click
        no: unknown argument
        Router could not be initialized!
      p というエラーメッセージが出てルーターが作動しない。スペースは不可だと分かる。
      p このような試行錯誤でもClickの作法は学べるが、いささか場当たり的である。より体系的な方法としては、該当するエレメントのmanを読むという手がある。
      pre.console
        man Print    # printとすると、ヒットしない！ 大文字にすること
      p これで、PrintエレメントについてのClick公式側が用意した全ての説明を読むことができる。ただし実際に読んでみると、「テキスト(manの説明ではLABEL)にスペースが含められない」、さらに言えば「'(クォーテーション)または"(ダブルクォーテーション)で括れば書ける」という事実は明記されていない。このような暗黙の了解事項は、何度もルーターを少し変えては動かすことで学ぶのが一番早いだろう。

      h4#read-thesis Elementとその関連概念を知る
      h5 Configuration File
      p まず初めに、今までの話に登場してきた.clickという拡張子のファイルはConfiguration Fileと呼ばれる。以下では「コンフファイル」もしくは「コンフィグファイル」と略記する。ルーターに実現させたい処理を記述したファイルである。
      pre.console
        click myFile.click
      p のように標準入力からクリックのプログラムに渡して実行することで、内部に記された処理が実行される。
      p
        | よって「Clickでルーターを作る」と言った際、その最終段階はこの
          strong コンフィグファイルを作り、<br>各処理ごとのConfiguration String(引数)を修正する
          ことだと言える。ルーターを作る、という想像も付かないような作業を、必要最小限の場合としてこのレベルまで抽象化したことがClickの功績であろう。
      p コンフファイルはより具体的には、elementと呼ばれる処理のまとまり（ふつうのプログラミング書籍でいわれるモジュールに相当する）を並べて作られる。FromDevice(eth0) -> Print(ok) -> ToDevice(eth0);という1行のコンフファイルであれば、FromDevice(eth0)とPrint(ok)とToDevice(eth0)の３つがelementである。

      h5 element
      p 訳さずにelementのまま理解したほうが良いと思われる。「オブジェクト志向」を「物体志向」と訳さないのと同じ理由である。作者の設計思想が如実に反映されており、日本語の「要素」にはない細かな形式的な制限がある。
      p
        | input port, output port, configuration string, element classの4つで主に構成される。図解や制限は
        a(href="http://pdos.csail.mit.edu/papers/click:tocs00/paper.pdf") click作者の論文
        | のp.4にあるelementの図に任せる。
      p p.4の図からはinput portは全てのelementに必要に思えるが、そのすぐ下の図を見るとFromDeviceなどはinput portがない。同様にToDeviceにはoutput portがない。最終的にelementを自作する際は、このように設計段階でのinput portやoutput portの数、またpullやpushと言った処理の種類に合わせてコードを書いていくことになる。

      h5 pull, push, agnostic
      p 
        | 上記論文p.4のelementの図において、黒く塗りつぶされている三角・四角がpushのinput portとoutput portであり、そうでない三角・四角がpullのinput portとoutput portである。pushのinput portはpushのoutput portにしか繋げない。またpullのinput portはpullのoutput portにしか繋げない。絵で言えば、
        strong ■ → ▲と□ → △だけが許されて、■ →△と□ → ▲は許されない
        ということである（エラーが出て落ちる）。agnosticは後続するelementがpushならばpush, pullならばpullになる柔軟なelementである。一般的な訳は「不可知論者」である。実装するのが難しそうな気がする。

      p このpushとpullがC++上でどのように実現されているかはclick/elements/standard/nullelement.ccを見ると掴めるかもしれない?
      pre.console
        | void
          PushNullElement::push(int, Packet *p)
          {
          output(0).push(p);
          }

          PullNullElement::PullNullElement()
          {
          }

          Packet *
          PullNullElement::pull(int)
          {
          return input(0).pull();
          }
      h5 keywords
      p 
        a(href="http://www.read.cs.ucla.edu/click/elements") elementを1つ1つ説明している公式ドキュメント
        では、KEYWORDSという単語が登場する。LIMIT 5のLIMITなどがそれである。
      p 論文から理解したいことは以上の4つである。論文後半ではCPUスケジューリングについて言及があるが、パフォーマンスを考慮する段階になるまで放っておいて構わない。
      h6 注. configuration stringの書き方、文法
      p http://www.read.cs.ucla.edu/click/docs/language#configuration-stringsに文字列、IPアドレスなどconfiguration string１つ１つの記法が紹介されている。大体C++と同じだが、空白とコメントしか続かないカンマは無視される（即ちPrint(1,)とPrint(1)は同じ扱い）などはC++ではエラーが出る文法なので、例外的な拡張である。
      p 上のURLの説明をhttp://www.read.cs.ucla.edu/click/elements以下にある各elementの説明と併用すれば問題なく一発で書けるはず。
      h4#write-ip-router (発展)既存のelementでIPルータを作る
      p 日経ネットワーク2013年12月号で『ソフトウェア教材「Click」で学ぶルーターの動作』という20pほどの特集が組まれている。おそらく2014年3月現時点でClickの動作について日本語でまとまって解説されているのはこの特集だけだと思われる。数十個の既存elementを組み合わせるとARP処理まで含めたＩＰルータが作れると述べている。日経の雑誌なので学内回線もしくはssl-vpnで読めるらしい。


      h3 情報の探し方を整理する
      h4 which, locateコマンド
      pre.console
        | which click           # clickという名前のバイナリを探し、一番最初に見つかったものを返す
          /usr/local/bin/click  #
      p | /usr/binに新しくインストールしたが/usr/local/binが先に見つかってしまい使えない、というバグが発見できる。一番簡単な解決策は
      pre.console
        /usr/bin/click  # 絶対パスで指定することである。

      h4 find, grepコマンド
      pre.console
        | find . -name click*
      p カレントディレクトリ . 以下に存在する、clickで始まる任意のファイルの絶対パスを全て表示する。
      h4 ctags, cscopeライブラリ
      p 関数名から関数定義へ飛べるツール。筆者は使用中のエディタで使えるctagsを利用している。
      h4 Sublime Text 3の機能
      p Sublime Text 3はソースコード内の検索機能に優れたテキストエディタである。
      h5 findの強化版 (ctrl + p)
      img(src="img/find_sublime.png")
      p findとは違い、正規表現を書く必要がない。
      h5 grepの強化版 (ctrl + shift + f)
      img(src="img/grep_sublime.png")
      p grepとは違い、ハイパーリンク機能が付いている。行番号をクリックするとファイルが別タブで開く。
      h4 ドキュメント
      h5 ElementsとDriver
      p
        | オンラインでは
        a(href="http://www.read.cs.ucla.edu/click/elements") 個別エレメントの紹介ページ
        | と、
        a(href="http://www.read.cs.ucla.edu/click/docs") 内部ツールの紹介ページ
        | から読める。オフラインではman Printなどで読める。ただしDriverのmanを初期に参照することは無いだろう。
        | また、apropos Classifierとすると、manの全文内検索が行える。

      h5 API(doxygen)
      p 
        | オンラインでは
        a href="http://read.cs.ucla.edu/click/doxygen/" API documentation
        | から読める。このドキュメントは初めにgit cloneしたClickの中、すなわちclick/doc以下に入っているので、doxygenというプログラムで生成すればオフラインでも読める。方法は
        a(href="#offline-doxygen") こちらの章
        | を参照のこと。
      h4 Linuxの実行中情報
      ul
        li ifconfig   # NICのIPアドレス、MACアドレス、ONかOFFかを確認する。
        li netstat    # 現在ソケット通信を行っているプログラムを表示する。
        li route      # ルーティング表を表示する。インターネットから切り離して数台で実験する時に、静的ルーティングを設定するために使う。
        li traceroute # パケットが届くまでに通るルーターを一覧表示する。
        li strace     # Linuxのみ。プログラム内で呼び出したシステムコールを表示する。ソースコードを読むよりも早く実行内容を理解できるケースがある。
        li wireshark  # パケットキャプチャ。きちんとNICに届いているかなどを確認できる。
        li tcpdump    # 同上


      h3 作ってみる
      h4#null-element 何もしないNullElement
      p
        | 自作のelementを使う場合、言っておかないと確実に誰もがハマって数時間を費やす注意点は
        strong ./configureのときに--enable-localオプションをつけておく必要がある
        ということである。これをしておかないと以下でclick/elements/local以下に自作のelementを追加しても、sudo make installされたとき（clickが、その自作のelementを含めてプログラムを再構成するとき）にコンパイルされない。
      p
        | このチュートリアルでは
        a(href="#install-click") インストールする
        | の章で既にそれに言及しているため問題はないだろうが、仮にそのオプションを指定していない場合は上記のURLの./configure --prefix=$HOMEを実行する前の作業から、設定をやり直す必要が生じる。
      p click/elements/local以外のディレクトリでも作る方法を以下でも解説するが、まだ一部しか理解していない(EXTRA_DRIVER_OBJSのような、外部ライブラリを使う際に違いが生じるようである)。

      p 自作elementを追加したあとは、毎回
      pre.console
        | #「sudo make install」でコンパイルされるelementの一覧(click/elements.conf)を書き換えるコマンド。
          make elemlist
          # elements.confに従って自作elementをコンパイルする。C++の文法ミスなどはここでエラーが出る。
          sudo make install
      p の2つのコマンドを実行する(elements/local以下に追加した場合はsudo make elemlistしなくても良かった気が...未確認)。それ以後、click myConfig.clickなどのコンフファイルの中でその自作elementを実行できるようになる。（myConfig.clickを実行している最中に落ちた場合は、コンフィグファイルのelementの配置順の誤解、もしくは例外処理の不足が生じてエラーを出していると思われる。man 1 clickにあるようにCLICK_BACKTRACEをONにすると原因が掴めるかも？）

      p 
        | 以上に書いたような「新しいelementの作り方」の概要は
        a(href="http://www.read.cs.ucla.edu/click/faq#creating-your-own-elements") FAQ
        | にまとまっている。
      p class_name(), port_count()は必ず実装する。push(), pull(), simple_action()はそれぞれ、push, pull, agnosticなoutput portを持つelementがそれぞれ実装する（３つのうち、どれか１つだけということである）。以上を踏まえて、click/elements/standard/nullelement.ccを参考に作る。
      p 
        | 更に詳しい情報は、
        a(href="http://www.read.cs.ucla.edu/click/doxygen/class_element.html")こちら
        | にまとまっている。

      h4#api-element 内部APIを用いるelement
      p 新しいelementをClickで実装する際はAPIの理解が必須である。Clickは一般的なC++プログラマなら普通使うであろう「C++のSTLに含まれるStringなどの標準ライブラリクラス」を使わず、独自にそれらのStringクラスに相当するものをを実装し直して使うなどしており、呼び出す関数名や返ってくる戻り値などについてClick内部のソースコードを見ながら逐一確認する必要があるからだ。
      p API（クラスとそのメンバ関数群）はhttp://read.cs.ucla.edu/click/doxygen/classes.html にまとまっている。実際にはPacket.hhの説明を読んだ後、右上の虫眼鏡で検索したり、各タブを利用することでAPIを探していく。
      p なおこのAPIドキュメントはオフライン閲覧もできる。後述する。

      h4 外部ライブラリを呼び出す
      p coming soon

      h4 elements/local/以外の場所に自作エレメントを作る
      p
        | click/etc/samplepackage/READMEにあるが、コマンドの実行順序が読み取れない。不完全だが、以下までは把握した。なお、
        strong 事前にclick/etc/samplepackage以下のファイルを新規フォルダにコピーしておく
        とよい。
      pre.console
        | pwd                # ->  ~/click/etc/samplepackage    
          ls                 # ->  configure.ac   Makefile.in   README   sampleelt.cc   sampleelt.hh   test.click

          autoconf           # -> configure.acに基づき、configureコマンドが作成される。
          \./configure        # -> Makefile.inに基づき、Makefileファイルが作成される。
          make elemlist      # -> .ccファイル内のEXPORT_ELEMENTなどから　sample-{k,m}elements.conf　と　sample-uelem.mkが作成される。
          make               # -> sample.koなど大量のオブジェクトファイルが作成される。
          sudo make install  # -> sample.uoなどが無事に/usr/bin/以下あたりにインストールされる。これによって初めて以下のコマンドが成功する。
          click test.click   # -> test.click: 3: While initializing 'test :: SamplePackageElement':
          Successfully linked with package!
      h4 独自の.oファイルを利用する
      p configure.in内のEXTRA_DRIVER_OBJSをセットしよう。ただし、samplepackageのように別パッケージで作った場合、sudo makeは成功しても.clickファイルの実行時にundefined symbolエラーとなる。elements/local以下に置いた場合に.clickの実行まで含めて成功することは確認した。

      h4 ElementClassにより複雑なエレメントを作る（IPフォワーディングをするエレメントを作る）
      p フォワーディング」とは、あるNICから入ってきたパケットを別のNICから送信する動作のことだ。主としてルータが行ない、特にIPパケットの場合はIPフォワーディングと呼称される。
      p Linux環境では、/proc/sys/net/ipv4/ip_forwardの値を1にすると、自動的にIPフォワーディングの機能が有効になる(echo 1 > /proc/sys/net/ipv4/ip_forwardとすればよい。元に戻すにはecho 0 > /proc/sys/net/ipv4/ip_forwardとすればよい。)。これにおよそ相当する動作を、Clickのエレメントで実装してみると以下のようになる。
      pre.console
        | elementclass MacRewriter{ $src, $dst |
            input                              // assume with ethernet header
            -> Print(____________BEFORE_REWRITING____________, MAXLENGTH 100)
            -> Strip(14)                       // remove ether header
            -> EtherEncap(0x0800, $src, $dst)  // attach new ether header
            -> Print([$src]->[$dst], MAXLENGTH 100)
            -> output
          }

          FromDevice(eth0)
          -> MacRewriter(33:33:33:33:33:33 /*src*/, 44:44:44:44:44:44 /*dst*/)
          -> Queue -> ToDevice(eth1);

          // backward
          FromDevice(eth1)
          \-> MacRewriter(22:22:22:22:22:22, 11:11:11:11:11:11)
          \-> Queue -> ToDevice(eth0);
      img(src="img/ip_forwarding.png")
      p 上図のような状況で、Machine2上で上記のClickソフトウェアルーターをClickコマンドで起動した場合、10.0.0.1/8と11.0.0.2/8という異なるネットワーク間でのホストでデータのやりとりができる。Machine1からpingが通るかping 11.0.0.2/8をして試してみよう。もっともこの場合、隣り合うマシンのMACアドレスを知っていなければならず、あまり現実的ではない（？）。
      p なおVirtualBoxを使っている場合はVboxManageのclonevdiコマンドを用いれば、複数台のVMの用意が楽になると思われる。
      h4 エレメントにTelnet接続する
      p 
        | エレメントのマニュアル（man Printなど）には、MAXLENGTHなどのパラメタを列挙しているDESCRIPTIONとは別に、
        strong ELEMENT HANDLERS
        | という項目がある。この項目に記載されたデータは、Clickの実行プロセスにTelnet接続することで、実行時に読み取ることができる。

      pre.console
        | cat orera_wa_gomibako_yukisa.click # on the first terminal
          > FromDevice(en0) -> Discard();
          sudo click --port 777  orera_wa_gomibako_yukisa.click

          telnet localhost 777               # on the second terminal
          
          read list    # 稼働中のエレメントを一覧表示する
          200 Read handler 'list' OK
          DATA 53
          3
          FromDevice@1
          Discard@2
          click_driver@@ControlSocket
          
          read Discard@2.count  # Discardされたパケット数を確認する
          200 Read handler 'Discard@2.count' OK
          DATA 3
          177

      p 何かと役立つだろう。


      h3 更に調べる(まだ未整理)
      h4#two-arguments elementの2引数()
      pre
        | もう一つelementという概念の設計思想として指摘しておくべき点としては、elementは引数にあたるものを２種類取るということである。その２つとはパケットとconfiguration stringである。これは、コンフファイルを書く最終段階でも、後述する「新しいelementを作る過程」でも、常に2種類を意識する必要がある。全然違う性格を持つからである。

          【コンフファイルを書く最終段階において】
          たとえば　FromDevice(eth0) -> Print(ok) -> Discard;　という1行だけのコンフファイルで考えてみる。
          configuration stringは関数の引数のような形式で渡されている。たとえばFromDeviceというelementにはeth0、Printというelementにはokが渡されている。
          一方でパケットは、 -> という（矢印を模した）記号の前でプロセスされたものが引数として渡されている。　
          ->　が前に存在していないFromDeviceは -> ではなくconfiguration stringによって受け渡しが行われている。ここも忘れやすいので注意。

          【新しいelementを作る過程において】
          パケットはソースコード中ではPrint::simple_action(Packet *p){といったように関数の引数として渡されている。
          configuration stringは対応する.ccファイルの関数configure()の中で
          if (Args(conf, this, errh)
             .read_p("MAXLENGTH", bytes)
             .read("LENGTH", Args::deprecated, bytes)
             .read("TIMESTAMP", timestamp)
             .complete() < 0)
          return -1;
          のように、パースされたのちにsimple_actionなどのパケット処理を行う別の関数内で使えるようになっている。

          (simple_action()は、そのelementのもとにパケットが来た際に自動で（イベントドリブンで）呼び出される関数である。)


          一方で、elementはoutput portsの数自体はいくつあっても良いのに、他のelementに渡す物体としてはパケットだけというのは面白い。configuration stringを（コンフファイルにおける）後続のelementに渡すようなことは基本的には行われていないのである。パケットはカスケードのように次々に後続のelementに渡されていく一方で、configuration stringはそのelementだけが参照できるデータである。このように、clickにおけるデータの受け渡しには設計上の特徴がある。
      h4 StringクラスとStringAccumクラスの使い方を読んで学ぶ
      p StringAccumは、Click内部で文字列の連結をかんたんに行うためのクラスである。
      p 
        | そして、StringAccumクラスを学ぶのに最適なソースコードはズバリelements/userlevel/kernelfilter.cc内のdevice_filter()である。この関数は、実はこれまでずっと使ってきたFromDevice.uエレメント(ユーザーレベルのFromDevice)エレメントのSNIFFERというオプションをfalseにした際に呼び出される。まず、
        a(href="http://www.read.cs.ucla.edu/click/elements/fromdevice.u#description") FromDevice.uエレメントのSNIFFERオプションの説明
        を読んでみよう。
      pre
        | SNIFFER
          Boolean. Specifies whether FromDevice should run in sniffer mode. In non-sniffer mode, FromDevice installs KernelFilter filtering rules to block the kernel from handling any packets arriving on device DEVNAME. Default is true (sniffer mode).
          (大意：
          SNIFFER<br>
          FromDevice(eth0, SNIFFER true) もしくは FromDevice(eth0, SNIFFER false)  のように使う。デフォルトはtrue。falseにすると、.clickファイルを動かしたときに自動的にKernelFilterエレメントのメソッドが呼び出され、eth0に届いた全てのパケットをLinuxカーネルが扱うことを防ぐ。)
      p 要するに、FromDeviceエレメントのオプションとして、KernelFilterエレメントの一部機能が転用されている。この呼び出される「KernelFilterエレメントのメソッド」が上述のKernelFilter::device_filter()である。今度は、KernelFilterエレメントの説明(man KernelFilter、大文字を忘れずに)を読んでみよう。
      pre
        | DESCRIPTION
          The KernelFilter element installs filter rules in the kernel to stop the kernel from handling certain types of packets. Use this in combination with FromDevice.u to handle packets in user-level Click configurations. KernelFilter uses iptables(1) to install filters; if your system does not support iptables(1), KernelFilter will fail. Normally KernelFilter uses either /sbin/iptables or /usr/sbin/iptables. To override this use the IPTABLES_COMMAND keyword argument. KernelFilter uninstalls its firewall rules when Click shuts down. If Click shuts down uncleanly, for instance because of a segmentation fault or 'kill -9', then the rules will remain in place, and you'll have to remove them yourself.
          (大意:<br>
          KernelFilterエレメントは単にLinuxでファイヤーウォールを設定する際に使われる iptables コマンドのラッパーである。/sbin/iptables もしくは /usr/sbin/iptables にあるiptablesを、execl()システムコールで実行しているだけである。その２箇所のどちらにもない場合はもちろんエラーとなる。<br><br>
          KernelFilterによる呼出でインストールされたファイヤーウォールのフィルタリングルールすなわち<br>
          "/sbin/iptables -A INPUT -i eth0 -j DROP"  (append a rule)<br>
          などは、ClickのプログラムをCtrl - Cなどで終了させた際に<br>
          "/sbin/iptables -D INPUT -i eth0 -j DROP"  (drop a rule)<br>
          が自動的に呼ばれて消去される。ただしsegmentation faultなどで落ちた場合は残り続けるので注意。<br>
          上のコマンドを見て分かるように、残ってしまうとeth0に届いたパケットは全て捨てられてしまうので、何も通信ができない。
      p この「Clickが動いている時だけ適用されるフィルタリングルール」については、例えば以下のように確認ができる。
      img(src="mg/view_iptables.png")
      p Clickで作ったルーターがバックグラウンド(&)で動いている間だけ、DROP all -- anywhere anywhere なるとても強いフィルタリングルールが適用されていることが分かる。なおこのようなシェルプログラミングに苦手意識があるならば、"A practical guide to Linux commands, editors, and shell programming"(Mark G. Sobell, 2012)のChapter 2, 3, 4, 5, 8, 10を勧める。
      p さて、ここまで理解した上でKernelFilter::device_filter()を見てみると、内容は一目瞭然である。StringAccumのインスタンスに対して、"/sbin/iptables" か "/usr/sbin/iptables"のどちらかの文字列を<<演算子で読み込んで、その後ろに引数を読み込んで、上述のiptablesの実行コマンド文字列を用意しているだけである。この関数のソースコードからは、以下のことが学べる。
      ol
        li StringAccumクラスは&lt;&lt;演算子で文字列を連結できる。
        li StringAccum::take_string()関数で(Click独自の)Stringクラスに変換できる。
        li String.c_str()でchar *に変換できる。すなわちexecl()などのシステムコールに渡せる形にやっとここでなる。
      h4#click-detail-by-author 作者による内部解説
      p
        a(href="http://www.read.cs.ucla.edu/click/clickunderhood") ここ
        | が恐らく一番詳しい。
      h4#click-mailing-list 更に突っ込んだ話題はメーリングリストを漁る
      p 
        たとえば"global variable site:pdos.csail.mit.edu"で検索すると、
        a(href="http://pdos.csail.mit.edu/pipermail/click/2009-February/007659.html") ２つのエレメント間でデータを共有するにはグローバル変数で良いが、果たしてそれらのエレメントが同じコンフィグファイル内で複数回使われたらどうなるのか教えて欲しい
        | という話題が出てくる。残念ながらリンク先からはその答えが見つけられないが、自分がいま探しているのが２つのエレメント間での共有だけであれば、このページを読むだけでグローバル変数を.ccファイルに書けばよいと勘付けるだろう。

      h4 その他まだ未整理の話題
      h5 複数element間でのデータの受け渡し
      p ３つの方法を思いついた。
      ul
        li ColorというClick内部の空き場所を使う
        li 
          | http://www.read.cs.ucla.edu/click/docs/language#configuration-parametersの方法を使う。例として、click/conf/mazu-net.clickでは
          pre
            | elementclass GatewayDevice {
                $device |
                from :: FromDevice($device)
                -> output;
                input -> q :: Queue(1024)
                -> to :: ToDevice($device);
                ScheduleInfo(from .1, to 1);
              }
          | のように$deviceが2回参照されている。
        li .cc内でグローバル変数を宣言し、もう片方の.cc内でexternして受け取る。ただしこうやった場合に、同じエレメントが複数個.clickにあった場合、どのようなことが起きるのかは未確認。
      h5 configuration fileの作成方法
      pre.console
        | click/conf/test-device.clickというコンフファイルの実行内容は以下の1行のみである。

          FromDevice(eth0) -> Print(ok) -> Discard;

          これは、eth0というネットワークインターフェイス(以下NIC)からのパケットを全て「複製」し、okというラベルと共にそのパケットの「先頭何バイトか」を標準出力に表示したあと、そのパケットを「破棄する」というルーターに等しい。
          ここで一つ注意すべきなのは、「　」で括った語句の意味内容は、実際にはこのコンフファイルを読んだだけでは理解できない。「複製」と言うが、では元々NICに入ってきたパケット（複製元のパケット）はどうなっているのか。「先頭何バイトか」と言うがバイト数を変えることはできないのか。「破棄する」というが複製元のパケットも破棄するのか、それとも複製後のパケットだけを破棄するのかどうなのか。clickのコンフファイルは見た目の簡潔さを重視しているため、コンフファイルを見ただけではこれらの実行内容を調べることはできない。

          これらの実行内容を調べる手段は２つ存在する。

          １．公式サイトのelements (http://www.read.cs.ucla.edu/click/elements)のページにある英語という自然言語で読む。
          ２．click/elements以下にあるstandard/print.ccなどを直に読んで、処理内容をプログラミング言語という形式言語から読み解く。

          当然ながら2.の方が正確ではあるが、同時に残念ながら2.の方が難易度が高い。上述した「stringを自分で実装し直している」という比較的珍しい方針からも分かるように、Click自体はかなり高度なプログラミングテクニックを用いて記述されているため、線形に目を通したのではとても読めないコードが満載である。私もctagsなどのソースコード閲覧支援プログラムを用いて読解を試みているが全然歯が立たない。そのため、2.に挑む場合は以下のどちらかの理解支援方法が必要になるだろう。

          A.プログラミングの有識者に問い合わせる。究極的には作者Eddie Cohler氏に聞く。
          B.各種C++ライブラリの参考書とネットワークの専門書を頼りに理解していく。

          どちらも「必ず通用する、何度でも行える」というものではない。

          以上のことから、1.の公式サイトの記述を読むことがClickのelementsの理解方法としてふさわしいと思われる。ただし上述のelementsのページは辞書が好きな人なら分かると思うが入門書や講義調に描かれている訳ではなくあくまで「誰かにとっての必要事項（めったに使わない変数の設定なども含まれる）」を並べ立てている、いわば博物誌や標本のような情報の並べ方をしているので、通して全て読むといった形の読書が通じるものではない。以上のことから、Clickを勉強する際には常にelementsのページを横に開いておくスタイルが望ましいと思われる。

          elementsのページを飛ばし読みしながら、自分がルーターに付けたい機能を実現できるelementsはどれかを選択していく。
          これが「◆clickにおけるconfiguration fileにおいて」の最終段階として挙げた作業の、一つ前の作業だと思われる。これを作業Bと以下では呼称する。

          そして仮に、そのようなelementsを（まだan elementとして存在していない、もしくは既存のelementsを繋げれば求めている機能が実現されることに気付けなかった）などの理由で見出せなかった場合、作業Bと並行して「自分で新しいelementを実装する」という作業Cが必要となる。
      h5 以上で紹介したドキュメントに出てこない関数など
      p click/ns/nsclick.ccで定義される引数なしのclick_random()がそれである。このような関数の定義元を探す場合、ソースコードにタグ付けするcscopeや<a href="http://ctags.sourceforge.net/">ctags</a>といったソフトを使うしかないと思われる。私はsublime text 3のctagsパッケージにずいぶん助けられている。
      h5 オフラインでエレメントのドキュメントを読む
      p an FromDeviceなどとすると読める。なお、Linuxのネットワークコマンド（tcpdumpなど）がクリックのどこで使われているかを知るには、apropos tcpdumpなどとすると一覧できて便利かと思われる。
      h5#offline-doxygen オフラインでAPIドキュメントを読む
      p [Mac OS Xの場合]
      pre.console
        | brew install doxygen     # doxygenを何らかの方法でインストール
          cd (Clickのrootディレクトリ)/doc
          doxygen -u               # obsoleteになった設定事項を消去。必要ないかもしれない。
          doxygen                  # ドキュメントをhtmlで生成
          open html/index.html     # できあがったhtml/index.htmlから閲覧する
      p 手元の環境では、(Clickのrootディレクトリ)/doc/Doxyfile内で、
      ul
        li 変数DOC_FONTNAME（使われるフォント）を変更
        li 変数INPUTのパスを全て１階層上に変更(ドキュメントを含むソースコードが存在するフォルダ一覧。)<br>　たとえば、include/click ならば ../include/clickにする。
      p 以上を行うと環境によっては Check your TeX installation! という大量のエラーが表示されるが、.htmlのドキュメントファイルについては正常に生成される。ドキュメントのpdf化については個々人で対応されたい。

      h5 miscellaneous
      ol
        li click(1)にチラっと書いてあるCLICK_BACKTRACE怪しい これをONにすればエラー特定に役立つのではないか？
        li click(5)は言語について書いてる
      h5 clickの位置付け
      pre.console

        | （誤認の可能性が高い。よってこの項目の記述内容は容易に変動する。）
          ClickはUnix系OSにおけるネットワーク系コマンド群をKohler氏の思想によってまとめ上げ、機能を追加し、さらに拡張可能にした巨大なプログラムである。

          その複雑化の制御の過程で単に標準入力のコマンドのような設定項目の羅列や項目の羅列である設定ファイルではなく、DSLのような特性が生じた。
          (※DSL…Domain Specific Languageドメイン固有言語。特定のタスク遂行に特化した言語。コンパイル支援におけるmake、文章構造化におけるHTMLなどがその例。)
          Kohler氏の研究興味分野にプログラミング言語が入っていることは興味深い（networks, programming languagesと並ぶのは比較的珍しい）。

          その結果としてネットワークの設定が標準入力コマンドのオプション引数やいわゆる設定ファイルよりも遥かに人間の思考に沿ったかたちで記述・構築可能になった。これがClickの思想的な業績であると私は考える。この発想は東京大学・中尾彰宏教授のToy-Block Networkingなどの研究に影響を与えたと想定される。

          Clickは今まで述べてきたようにelements間については厳格な形式制限があるが、ソースコードのレベルにおいては様々なライブラリを柔軟に取り込むことができる。
          STLの標準ライブラリを取り込むことも可能であるし、たとえばnetstatの機能を内部に追加するなども(更に高度になるが)可能である。
          実際、ClickのKernelFilterエレメントはiptablesコマンドをそのまま呼び出している。
      h3 リンク
      ul
        li <a href="http://www.gnu.org/software/make/manual/make.html">GNU makeの公式マニュアル</a> ... Clickを学んでいてmakeについて疑問が生じたら、このマニュアルかAndrew Oramの『make 改訂版』を参照することを推奨する。makeはググって情報を探すことに向いていない。
        li 『ストラウストラップのプログラミング入門』 ... const参照の意義についての説明は感動。
        li 『詳説 Cポインタ』 ... 2章まで読むだけでも、ポインタの概要が分かる。
        li 『Linux Programming Interface』の41章 ... 静的/動的リンクについて詳細な説明がなされている。リンクのエラーはググっても解決策が出てこない（もしくはとても読みにくい）ことが多く、先に全体を知ってしまったほうが無難である。
      h4 その他
      ul
        li 誤植や誤解などありましたら<a href="https://github.com/caprice-j/click_tutorial_in_Japanese">github</a>へお願いします
        li 開発履歴
        li 20140324  何となく書き始める
        li 20140325  公開したら.txtですら案外好評だったので続ける気になる
        li 20140402  目次をフレーム化するためにhtml化
        li 20140530  IP forwardingの項を追加
        li 20140603  FAQの存在を発見、リンクに追加
        li 20140604  Haml, Scssで全て書き直した
        li 20140605  指摘を受けて修正　誤：element/nullelement.cc 　正： element/standard/nullelement.cc
