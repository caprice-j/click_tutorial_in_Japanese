====================================


　　Click Tutorial in Japanese
  2014/03/24

====================================


◆ ClickをとりあえずHello Worldに相当するところまで動かしてみる

http://www.read.cs.ucla.edu/click/tutorial1#preparationに従って行なう。Problems以下の項目は必要ない。
root権限がないと動作しない。


◆ Clickにおけるconfiguration fileについて

configuration fileとは「.click」という拡張子が付いたファイルである。以下では「コンフファイル」もしくは「コンフィグファイル」と略記する。
コンフファイルの中にはルーターに実現させたい処理を書く。そのコンフファイルを
click testFile.click
のように標準入力からクリックのプログラムに渡して実行することで、内部に記された処理が行なわれる。
よって「Clickでルーターを作る」と言った際、その最終段階はこの「コンフファイルを作り（各処理ごとのconfiguration string(引数のようなもの)を）修正する」ことだと言える。
その詳細はhttp://www.read.cs.ucla.edu/click/docs/languageに詳しくまとまっているが、少し作った後でないと読んでも理解できないと思われる。

コンフファイルはより具体的には、elementと呼ばれる処理のまとまり（まとまり度合いは、ふつうのプログラミング書籍で紹介されるモジュールに相当する）を並べて作られる。


◆ Clickにおけるelementについて（１）elementの各部分の名前と数

elementは「元素；要素」などの意味がある英単語であるが、Clickにおけるelementはおおよそ後者に相当する。
ただしこのelementという概念が何なのかは、作者の設計思想が如実に反映されているため、理解に相当な注意を要する。

単に「要素」だと思っていると、以下で述べる「elementの組み合わせ」や「新しいelementを作る」と言った話が、「要素の組み合わせ」や「新しい要素を作る」という非常にあいまいで捉えどころのないものになる。コンピュータサイエンスで「木」と言えば、緑の葉が生い茂る樹木ではなく、節と枝で構成されており根が一番上というおよそ樹木とは似ても似つかない対象を扱うのと同じように、Clickで「element」といった場合それは一般に言う「要素」という「全体を余りなく分割したもの、全て組み合わせると全体が完成するもの」という意味内容に加え、そのelementという言葉で指示された物体の形式に細かな制限があることを表している。

以上の説明は曖昧すぎるので更に詳しく追及する。Clickのelementは作者のClick発表論文（http://pdos.csail.mit.edu/papers/click:tocs00/paper.pdf）のp.4にあるelementの解剖図を見ないと理解することは異常に困難である。それは熊を見たことない人に熊のシルエットはどんな感じか、毛の色合いはどのようかを伝えるような困難さを伴う。p.4の図はまさしくかつては作者Kohler氏の頭の中だけにあったであろうelementのイメージを表したものなので、p.3のFi gure 1 shows ...の段落から少し読んでみてほしい。ここではelementとは、
1つだけしか許されないinput portと、
0を含めず幾つあってもいいoutput portsと、
0も含めていくつあってもいいconfiguration stringと、
1つ以上存在するelement class名の、
以上4つで構成される物体だと指摘するに留め、熊を絵なしで説明するような野暮は行わない。
特にconfiguration stringについては論文で理解して頂きたい。

以上のelementを構成する4つの部分と、論文p.4の2.1で解説されているpullとpushという概念が、elementについてまず理解すべきことの全てである。論文ではその後はCPUスケジューリングはどうなっているのか、30個ぐらいelementを並べるとどんな機能が実現できるのかなどについて記載があるが、応用的な話題であるため最初は無視すべきである。


◆Clickにおけるelementについて（２）入力として扱うものはパケットとconfiguration string

もう一つelementという概念の設計思想として指摘しておくべき点としては、elementは引数にあたるものを２種類取るということである。その２つとはパケットとconfiguration stringである。これは、コンフファイルを書く最終段階でも、後述する「新しいelementを作る過程」でも、常に2種類を意識する必要がある。全然違う性格を持つからである。

【コンフファイルを書く最終段階において】
たとえば　FromDevice(eth0) -> Print(ok) -> Discard;　という1行だけのコンフファイルで考えてみる。
configuration stringは関数の引数のような形式で渡されている。たとえばFromDeviceというelementにはeth0、Printというelementにはokが渡されている。
一方でパケットは、 -> という（矢印を模した）記号の前でプロセスされたものが引数として渡されている。　
->　が前に存在していないFromDeviceは -> ではなくconfiguration stringによって受け渡しが行われている。ここも忘れやすいので注意。

【新しいelementを作る過程において】
パケットはソースコード中ではPrint::simple_action(Packet *p){といったように関数の引数として渡されている。
configuration stringは対応する.ccファイルの関数configure()の中で
 if (Args(conf, this, errh)
	.read_p("MAXLENGTH", bytes)
	.read("LENGTH", Args::deprecated, bytes)
	.read("TIMESTAMP", timestamp)
	.complete() < 0)
	return -1;
のように、パースされたのちにsimple_actionなどのパケット処理を行う別の関数内で使えるようになっている。


一方で、elementはoutput portsの数自体はいくつあっても良いのに、他のelementに渡す物体としてはパケットだけというのは面白い。configuration stringを（コンフファイルにおける）後続のelementに渡すようなことは基本的には行われていないのである。パケットはカスケードのように次々に後続のelementに渡されていく一方で、configuration stringはそのelementだけが参照できるデータである。このように、clickにおけるデータの受け渡しには設計上の特徴がある。


◆（発展）複数element間でのデータの受け渡しについて

　以上のデータ受け渡し構造に基づいて考えると、複数element間で「同一の制御用のデータ」を扱うにはconfiguration stringではなくパケット自体に付与するしかないという発想に至る。この「同一の制御用のデータ」のことをClickではcolorと呼んでいる。

ただしcolorはバイト数に制限があるなど、elementより遥かに癖がある（形式上の制限が厳しい）ために、複数element間で大きな制御用データをやり取りしたい場合には自作elementを使うしかないと思われる。この点についてはまだ調査中である。


◆　configuration fileの作成方法について

click/conf/test-device.clickというコンフファイルの実行内容は以下の1行のみである。

FromDevice(eth0) -> Print(ok) -> Discard;

これは、eth0というネットワークインターフェイス(以下NIC)からのパケットを全て「複製」し、okというラベルと共にそのパケットの「先頭何バイトか」を標準出力に表示したあと、そのパケットを「破棄する」というルーターに等しい。
ここで一つ注意すべきなのは、「　」で括った語句の意味内容は、実際にはこのコンフファイルを読んだだけでは理解できない。「複製」と言うが、では元々NICに入ってきたパケット（複製元のパケット）はどうなっているのか。「先頭何バイトか」と言うがバイト数を変えることはできないのか。「破棄する」というが複製元のパケットも破棄するのか、それとも複製後のパケットだけを破棄するのかどうなのか。clickのコンフファイルは見た目の簡潔さを重視しているため、コンフファイルを見ただけではこれらの実行内容を調べることはできない。

これらの実行内容を調べる手段は２つ存在する。

１．公式サイトのelements (http://www.read.cs.ucla.edu/click/elements)のページにある英語という自然言語で読む。
２．click/elements以下にあるstandard/print.ccなどを直に読んで、処理内容をプログラミング言語という形式言語から読み解く。

当然ながら2.の方が正確ではあるが、同時に残念ながら2.の方が難易度が高い。上述した「stringを自分で実装し直している」という比較的珍しい方針からも分かるように、Click自体はかなり高度なプログラミングテクニックを用いて記述されているため、線形に目を通したのではとても読めないコードが満載である。私もctagsなどのソースコード閲覧支援プログラムを用いて読解を試みているが全然歯が立たない。そのため、2.に挑む場合は以下のどちらかの理解支援方法が必要になるだろう。

A.プログラミングの有識者に問い合わせる。究極的には作者Eddie Cohler氏に聞く。
B.各種C++ライブラリの参考書とネットワークの専門書を頼りに理解していく。

どちらも「必ず通用する、何度でも行える」というものではない。

以上のことから、1.の公式サイトの記述を読むことがClickのelementsの理解方法としてふさわしいと思われる。ただし上述のelementsのページは辞書が好きな人なら分かると思うが入門書や講義調に描かれている訳ではなくあくまで「誰かにとっての必要事項（めったに使わない変数の設定なども含まれる）」を並べ立てている、いわば博物誌や標本のような情報の並べ方をしているので、通して全て読むといった形の読書が通じるものではない。以上のことから、Clickを勉強する際には常にelementsのページを横に開いておくスタイルが望ましいと思われる。

elementsのページを飛ばし読みしながら、自分がルーターに付けたい機能を実現できるelementsはどれかを選択していく。
これが「◆clickにおけるconfiguration fileにおいて」の最終段階として挙げた作業の、一つ前の作業だと思われる。これを作業Bと以下では呼称する。

そして仮に、そのようなelementsを（まだan elementとして存在していない、もしくは既存のelementsを繋げれば求めている機能が実現されることに気付けなかった）などの理由で見出せなかった場合、作業Bと並行して「自分で新しいelementを実装する」という作業Cが必要となる。

（補足：
日経ネットワーク2013年12月号で『ソフトウェア教材「Click」で学ぶルーターの動作』という20pほどの特集が組まれている。
おそらく2014年3月現時点でClickの動作について日本語でまとまって解説されているのはこの特集だけだと思われる。）



◆Clickにおける新しいelementの実装方法について

新しいelementの作り方の手順自体はhttp://www.read.cs.ucla.edu/click/faq#creating-your-own-elementsにまとまっている。

それとは別に、新しいelementをClickで実装する際はAPIの理解が必須である。
その理由は、Clickは一般的なC++プログラマなら普通使うであろう「C++のSTLに含まれるStringなどの標準ライブラリクラス」を使わず、独自にそれらのStringクラスに相当するものをを実装し直して使うなどしており、呼び出す関数名や返ってくる戻り値などについてClick内部のソースコードを見ながら逐一確認する必要があるからだ。

API（クラスとそのメンバ関数群）はhttp://read.cs.ucla.edu/click/doxygen/classes.html にまとまっている。
実際には以下のタブを頻用することでAPIを探していく。

Classes:
  Alphabetical List: 全クラスの一覧。名前だけで探したい時に使う。
  Class List:        全クラスの一覧に加え一行説明が読める。
  Class Members:     クラスメンバ名で探し、「対応する説明」へのリンク先へ飛べる。特に関数やtypedefなどで引けるのはありがたい。
Files: 
  [code]:            ソースコードのうち.hhだけを一覧・閲覧できる。上述のClass Membersと共通の「対応する説明」へ飛べる。

  「対応する説明」とは、各関数の戻り値や引数、型情報など実際のソースコードレベルの情報である。


◆ Clickの位置づけについて

　（まだまだ勉強中の身であるため認識が間違っている可能性が高い。よってこの項目の記述内容は容易に変動するだろう。）
　ClickはUnix系OSにおけるネットワーク系コマンド群をKohler氏の思想によってまとめ上げ、機能を追加し、さらに拡張可能にした巨大なプログラムである。

その複雑化の制御の過程で単に標準入力のコマンドのような設定項目の羅列や項目の羅列である設定ファイルではなく、DSLのような特性が生じた。
(※DSL…Domain Specific Languageドメイン固有言語。特定のタスク遂行に特化した言語。コンパイル支援におけるmake、文章構造化におけるHTMLなどがその例。)
Kohler氏の研究興味分野にプログラミング言語が入っていることは興味深い（networks, programming languagesと並ぶのは比較的珍しい）。

その結果としてネットワークの設定が標準入力コマンドのオプション引数やいわゆる設定ファイルよりも遥かに人間の思考に沿ったかたちで記述・構築可能になった。これがClickの思想的な業績であると私は考える。この発想は東京大学・中尾彰宏教授のToy-Block Networkingなどの研究に影響を与えたと想定される。

Clickは今まで述べてきたようにelements間については厳格な形式制限があるが、ソースコードのレベルにおいては様々なライブラリを柔軟に取り込むことができる。
STLの標準ライブラリを取り込むことも可能であるし、たとえばnetstatの機能を内部に追加するなども(更に高度になるが)可能である。
実際、Clickのどれかのelementはiptablesコマンドをそのまま呼び出しているらしい。

===file end===
